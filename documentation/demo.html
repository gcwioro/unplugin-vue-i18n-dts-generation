<!DOCTYPE html>
<html lang="" >
<head >
  <meta charset="UTF-8" >
  <link rel="icon" href="/favicon.ico" >
  <meta name="viewport" content="width=device-width, initial-scale=1.0" >
  <title >Vite App</title >
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4" ></script >


  <style type="text/tailwindcss" >

    @reference "tailwindcss";
    @theme base;
    @theme components;
    @theme utilities;
    @theme utility;
    section {
      @apply bg-white rounded-lg px-6 py-5 border border-gray-200 shadow-gray-400 shadow-lg ;
    }

    div {
      @apply rounded-sm ;
    }

    h1 {
      @apply text-xl font-bold text-gray-900 ;
    }

    h2 {
      @apply text-lg font-semibold text-gray-800 mt-4 mb-2 ;
    }

    .border {
      @apply border border-gray-300 border-1;
    }

    .icon-box {
      @apply text-sm;
    }

    .code {

      @apply m-2 bg-gray-900 overflow-x-auto p-2 text-xs text-green-400 font-mono font-mono overflow-auto max-h-128 rounded-lg;
    }

    pre, .code-inline {
      @applay font-mono text-xs bg-gray-100 px-1.5 py-0.5 rounded;
    }

    .label {
      @apply mt-2 text-sm text-gray-600 mb-4;
    }

    p > b, div > b {
      @apply font-mono text-xs bg-gray-400/30 px-1.5 py-0.5 rounded
    }

    .sub-section {
      @apply mt-4 mb-8 p-2 pb-4  border-gray-300;
    }

    p {
      @apply text-gray-700 mb-2;
    }

    /* Base typography */
    .text-lg {
      @apply text-lg font-semibold text-gray-900 mb-2;
    }

    .text-description {
      @apply text-sm text-gray-600 mb-4;
    }

    /* Layout containers */
    .section {
      @apply bg-white rounded-lg shadow-sm px-6 py-5 border border-gray-200;
    }

    .sub-section {
      @apply space-y-3;
    }

    .grid-2 {
      @apply grid grid-cols-1 md:grid-cols-2 gap-3;
    }

    .grid-2-even {
      @apply grid grid-cols-2 gap-4;
    }

    /* Headers */
    .section-title {
      @apply text-lg font-semibold text-gray-900 mb-2;
    }

    .subsection-title {
      @apply text-sm font-semibold text-gray-700 mb-2;
    }

    .subsection-title-sm {
      @apply text-sm font-semibold text-gray-700 mb-3;
    }

    /* Labels and text */
    .label {
      @apply text-sm font-medium text-gray-700;
    }

    .label-bold {
      @apply font-bold text-sm;
    }

    .code-label {
      @apply text-xs text-gray-500 mb-1 font-mono;
    }

    .text-hint {
      @apply text-xs text-gray-400 mt-1;
    }

    /* Code blocks */
    .code {
      @apply bg-gray-900 rounded-lg p-3 text-xs text-green-400 font-mono overflow-x-auto;
    }

    .code-example {
      @apply font-mono bg-white px-2 py-1 rounded text-xs text-gray-700;
    }

    .code-inline {
      @apply font-mono text-xs bg-gray-100 px-1.5 py-0.5 rounded;
    }

    /* Form inputs */
    .input {
      @apply px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent;
    }

    .select {
      @apply px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent;
    }

    .range {
      @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500;
    }

    /* Form groups */
    .form-group {
      @apply flex flex-col gap-1.5;
    }

    /* Info boxes */
    .info-box {
      @apply p-4 rounded-lg border;
    }

    .info-box-blue {
      @apply bg-blue-50 border-blue-200;
    }

    .info-box-amber {
      @apply bg-amber-50 border-amber-200;
    }

    .info-box-green {
      @apply bg-green-50 border-green-200;
    }

    .info-box-purple {
      @apply bg-purple-50 border-purple-200;
    }

    .info-box-yellow {
      @apply bg-yellow-50 border-yellow-200;
    }

    .info-box-red {
      @apply bg-red-50 border-red-200;
    }

    .info-box-indigo {
      @apply bg-indigo-50 border-indigo-200;
    }

    .info-box-pink {
      @apply bg-pink-50 border-pink-200;
    }

    .info-box-gray {
      @apply bg-gray-50 border-gray-200;
    }

    /* Info box titles */
    .info-title-blue {
      @apply text-sm font-semibold text-blue-900 mb-2;
    }

    .info-title-amber {
      @apply text-sm font-semibold text-amber-900 mb-2;
    }

    .info-title-green {
      @apply text-sm font-semibold text-green-900 mb-2;
    }

    .info-title-purple {
      @apply text-sm font-semibold text-purple-900 mb-2;
    }

    /* Info box text */
    .info-text-blue {
      @apply text-sm text-blue-800;
    }

    .info-text-amber {
      @apply text-xs text-amber-800;
    }

    .info-text-green {
      @apply text-sm text-green-800;
    }

    .info-text-purple {
      @apply text-sm font-medium text-purple-900;
    }

    .info-text-indigo {
      @apply text-sm font-medium text-indigo-900;
    }

    .info-text-pink {
      @apply text-sm font-medium text-pink-900;
    }

    /* List styles */
    .info-list {
      @apply space-y-1;
    }

    .info-list-item {
      @apply flex items-start gap-2;
    }

    .bullet-blue {
      @apply text-blue-400;
    }

    .bullet-amber {
      @apply text-amber-400;
    }

    /* Cards and panels */
    .card {
      @apply border border-gray-200 rounded-lg p-4;
    }

    .card-gray {
      @apply border border-gray-200 rounded-lg p-3 bg-gray-50;
    }

    .card-content {
      @apply px-3 py-2 bg-gray-50 rounded text-sm;
    }

    .card-white {
      @apply px-3 py-2 bg-white rounded text-sm;
    }

    .card-white-border {
      @apply px-3 py-2 bg-white border border-green-200 rounded text-sm;
    }

    /* Status badges */
    .badge-blue {
      @apply w-6 h-6 flex items-center justify-center bg-blue-500 text-white text-xs font-medium rounded-full;
    }

    /* Dividers */
    .divider {
      @apply pt-6 border-t border-gray-200;
    }

    /* File path display */
    .file-path {
      @apply font-mono text-xs bg-gray-100 px-1.5 py-0.5 rounded;
    }

    .file-path-green {
      @apply font-mono text-xs bg-green-100 px-1.5 py-0.5 rounded;
    }

    .file-path-blue {
      @apply font-mono text-xs bg-blue-100 px-1 rounded;
    }

    /* Status message boxes */
    .status-success {
      @apply px-3 py-2 bg-green-50 border border-green-200 rounded text-sm text-green-800;
    }

    .status-warning {
      @apply px-3 py-2 bg-yellow-50 border border-yellow-200 rounded text-sm text-yellow-800;
    }

    .status-error {
      @apply px-3 py-2 bg-red-50 border border-red-200 rounded text-sm text-red-800;
    }

    /* Settings items */
    .setting-item {
      @apply flex items-center justify-between py-2 px-3 bg-gray-50 rounded;
    }

    /* Menu items */
    .menu-item {
      @apply flex items-center gap-2 text-sm text-gray-700 py-2 px-3 bg-gray-50 rounded-md;
    }

    /* Icon containers */
    .icon-box {
      @apply flex items-center gap-2 mb-2;
    }

    .icon-green {
      @apply w-5 h-5 text-green-600;
    }

    .icon-blue {
      @apply w-5 h-5 text-blue-600;
    }

    .icon-success {
      @apply w-4 h-4 text-green-500;
    }

  </style >

</head >
<script type="module" crossorigin >(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r);
  new MutationObserver(r => {
    for (const i of r) if (i.type === "childList") for (const l of i.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && s(l)
  }).observe(document, {childList: !0, subtree: !0});

  function n(r) {
    const i = {};
    return r.integrity && (i.integrity = r.integrity), r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
  }

  function s(r) {
    if (r.ep) return;
    r.ep = !0;
    const i = n(r);
    fetch(r.href, i)
  }
})();

/**
 * @vue/shared v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/function zs(e) {
  const t = Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return n => n in t
}

const re = {}, Bt = [], tt = () => {
  }, Wi = () => !1,
  is = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  er = e => e.startsWith("onUpdate:"), Le = Object.assign, tr = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
  }, To = Object.prototype.hasOwnProperty, ee = (e, t) => To.call(e, t),
  j = Array.isArray, Gt = e => Nn(e) === "[object Map]",
  ls = e => Nn(e) === "[object Set]", Ar = e => Nn(e) === "[object Date]",
  K = e => typeof e == "function", pe = e => typeof e == "string",
  st = e => typeof e == "symbol", ie = e => e !== null && typeof e == "object",
  Hi = e => (ie(e) || K(e)) && K(e.then) && K(e.catch),
  Vi = Object.prototype.toString, Nn = e => Vi.call(e),
  So = e => Nn(e).slice(8, -1), ji = e => Nn(e) === "[object Object]",
  nr = e => pe(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
  fn = zs(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  os = e => {
    const t = Object.create(null);
    return (n => t[n] || (t[n] = e(n)))
  }, Lo = /-\w/g, St = os(e => e.replace(Lo, t => t.slice(1).toUpperCase())),
  Io = /\B([A-Z])/g, Ut = os(e => e.replace(Io, "-$1").toLowerCase()),
  Ki = os(e => e.charAt(0).toUpperCase() + e.slice(1)),
  ys = os(e => e ? `on${Ki(e)}` : ""), Tt = (e, t) => !Object.is(e, t),
  Wn = (e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t)
  }, Yi = (e, t, n, s = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: s,
      value: n
    })
  }, Yn = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
  };
let Dr;
const as = () => Dr || (Dr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function sr(e) {
  if (j(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const s = e[n], r = pe(s) ? Oo(s) : sr(s);
      if (r) for (const i in r) t[i] = r[i]
    }
    return t
  } else if (pe(e) || ie(e)) return e
}

const xo = /;(?![^(]*\))/g, Co = /:([^]+)/, No = /\/\*[^]*?\*\//g;

function Oo(e) {
  const t = {};
  return e.replace(No, "").split(xo).forEach(n => {
    if (n) {
      const s = n.split(Co);
      s.length > 1 && (t[s[0].trim()] = s[1].trim())
    }
  }), t
}

function rr(e) {
  let t = "";
  if (pe(e)) t = e; else if (j(e)) for (let n = 0; n < e.length; n++) {
    const s = rr(e[n]);
    s && (t += s + " ")
  } else if (ie(e)) for (const n in e) e[n] && (t += n + " ");
  return t.trim()
}

const Po = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  Ao = zs(Po);

function Bi(e) {
  return !!e || e === ""
}

function Do(e, t) {
  if (e.length !== t.length) return !1;
  let n = !0;
  for (let s = 0; n && s < e.length; s++) n = cs(e[s], t[s]);
  return n
}

function cs(e, t) {
  if (e === t) return !0;
  let n = Ar(e), s = Ar(t);
  if (n || s) return n && s ? e.getTime() === t.getTime() : !1;
  if (n = st(e), s = st(t), n || s) return e === t;
  if (n = j(e), s = j(t), n || s) return n && s ? Do(e, t) : !1;
  if (n = ie(e), s = ie(t), n || s) {
    if (!n || !s) return !1;
    const r = Object.keys(e).length, i = Object.keys(t).length;
    if (r !== i) return !1;
    for (const l in e) {
      const o = e.hasOwnProperty(l), a = t.hasOwnProperty(l);
      if (o && !a || !o && a || !cs(e[l], t[l])) return !1
    }
  }
  return String(e) === String(t)
}

function wo(e, t) {
  return e.findIndex(n => cs(n, t))
}

const Gi = e => !!(e && e.__v_isRef === !0),
  H = e => pe(e) ? e : e == null ? "" : j(e) || ie(e) && (e.toString === Vi || !K(e.toString)) ? Gi(e) ? H(e.value) : JSON.stringify(e, Xi, 2) : String(e),
  Xi = (e, t) => Gi(t) ? Xi(e, t.value) : Gt(t) ? {[`Map(${t.size})`]: [...t.entries()].reduce((n, [s, r], i) => (n[vs(s, i) + " =>"] = r, n), {})} : ls(t) ? {[`Set(${t.size})`]: [...t.values()].map(n => vs(n))} : st(t) ? vs(t) : ie(t) && !j(t) && !ji(t) ? String(t) : t,
  vs = (e, t = "") => {
    var n;
    return st(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  };
/**
 * @vue/reactivity v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/let Oe;

class Ji {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Oe, !t && Oe && (this.index = (Oe.scopes || (Oe.scopes = [])).push(this) - 1)
  }

  get active() {
    return this._active
  }

  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, n;
      if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].pause()
    }
  }

  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, n;
      if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].resume()
    }
  }

  run(t) {
    if (this._active) {
      const n = Oe;
      try {
        return Oe = this, t()
      } finally {
        Oe = n
      }
    }
  }

  on() {
    ++this._on === 1 && (this.prevScope = Oe, Oe = this)
  }

  off() {
    this._on > 0 && --this._on === 0 && (Oe = this.prevScope, this.prevScope = void 0)
  }

  stop(t) {
    if (this._active) {
      this._active = !1;
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++) this.effects[n].stop();
      for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++) this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, s = this.scopes.length; n < s; n++) this.scopes[n].stop(!0);
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !t) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index)
      }
      this.parent = void 0
    }
  }
}

function Fo(e) {
  return new Ji(e)
}

function Ro() {
  return Oe
}

let oe;
const Es = new WeakSet;

class qi {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Oe && Oe.active && Oe.effects.push(this)
  }

  pause() {
    this.flags |= 64
  }

  resume() {
    this.flags & 64 && (this.flags &= -65, Es.has(this) && (Es.delete(this), this.trigger()))
  }

  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Zi(this)
  }

  run() {
    if (!(this.flags & 1)) return this.fn();
    this.flags |= 2, wr(this), zi(this);
    const t = oe, n = Ge;
    oe = this, Ge = !0;
    try {
      return this.fn()
    } finally {
      el(this), oe = t, Ge = n, this.flags &= -3
    }
  }

  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep) or(t);
      this.deps = this.depsTail = void 0, wr(this), this.onStop && this.onStop(), this.flags &= -2
    }
  }

  trigger() {
    this.flags & 64 ? Es.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }

  runIfDirty() {
    Ds(this) && this.run()
  }

  get dirty() {
    return Ds(this)
  }
}

let Qi = 0, dn, mn;

function Zi(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = mn, mn = e;
    return
  }
  e.next = dn, dn = e
}

function ir() {
  Qi++
}

function lr() {
  if (--Qi > 0) return;
  if (mn) {
    let t = mn;
    for (mn = void 0; t;) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n
    }
  }
  let e;
  for (; dn;) {
    let t = dn;
    for (dn = void 0; t;) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1) try {
        t.trigger()
      } catch (s) {
        e || (e = s)
      }
      t = n
    }
  }
  if (e) throw e
}

function zi(e) {
  for (let t = e.deps; t; t = t.nextDep) t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t
}

function el(e) {
  let t, n = e.depsTail, s = n;
  for (; s;) {
    const r = s.prevDep;
    s.version === -1 ? (s === n && (n = r), or(s), Mo(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r
  }
  e.deps = t, e.depsTail = n
}

function Ds(e) {
  for (let t = e.deps; t; t = t.nextDep) if (t.dep.version !== t.version || t.dep.computed && (tl(t.dep.computed) || t.dep.version !== t.version)) return !0;
  return !!e._dirty
}

function tl(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === yn) || (e.globalVersion = yn, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Ds(e)))) return;
  e.flags |= 2;
  const t = e.dep, n = oe, s = Ge;
  oe = e, Ge = !0;
  try {
    zi(e);
    const r = e.fn(e._value);
    (t.version === 0 || Tt(r, e._value)) && (e.flags |= 128, e._value = r, t.version++)
  } catch (r) {
    throw t.version++, r
  } finally {
    oe = n, Ge = s, el(e), e.flags &= -3
  }
}

function or(e, t = !1) {
  const {dep: n, prevSub: s, nextSub: r} = e;
  if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), n.subs === e && (n.subs = s, !s && n.computed)) {
    n.computed.flags &= -5;
    for (let i = n.computed.deps; i; i = i.nextDep) or(i, !0)
  }
  !t && !--n.sc && n.map && n.map.delete(n.key)
}

function Mo(e) {
  const {prevDep: t, nextDep: n} = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0)
}

let Ge = !0;
const nl = [];

function _t() {
  nl.push(Ge), Ge = !1
}

function ht() {
  const e = nl.pop();
  Ge = e === void 0 ? !0 : e
}

function wr(e) {
  const {cleanup: t} = e;
  if (e.cleanup = void 0, t) {
    const n = oe;
    oe = void 0;
    try {
      t()
    } finally {
      oe = n
    }
  }
}

let yn = 0;

class ko {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
  }
}

class ar {
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0
  }

  track(t) {
    if (!oe || !Ge || oe === this.computed) return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== oe) n = this.activeLink = new ko(oe, this), oe.deps ? (n.prevDep = oe.depsTail, oe.depsTail.nextDep = n, oe.depsTail = n) : oe.deps = oe.depsTail = n, sl(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const s = n.nextDep;
      s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = oe.depsTail, n.nextDep = void 0, oe.depsTail.nextDep = n, oe.depsTail = n, oe.deps === n && (oe.deps = s)
    }
    return n
  }

  trigger(t) {
    this.version++, yn++, this.notify(t)
  }

  notify(t) {
    ir();
    try {
      for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
    } finally {
      lr()
    }
  }
}

function sl(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let s = t.deps; s; s = s.nextDep) sl(s)
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e
  }
}

const ws = new WeakMap, Mt = Symbol(""), Fs = Symbol(""), vn = Symbol("");

function Se(e, t, n) {
  if (Ge && oe) {
    let s = ws.get(e);
    s || ws.set(e, s = new Map);
    let r = s.get(n);
    r || (s.set(n, r = new ar), r.map = s, r.key = n), r.track()
  }
}

function ut(e, t, n, s, r, i) {
  const l = ws.get(e);
  if (!l) {
    yn++;
    return
  }
  const o = a => {
    a && a.trigger()
  };
  if (ir(), t === "clear") l.forEach(o); else {
    const a = j(e), f = a && nr(n);
    if (a && n === "length") {
      const m = Number(s);
      l.forEach((_, T) => {
        (T === "length" || T === vn || !st(T) && T >= m) && o(_)
      })
    } else switch ((n !== void 0 || l.has(void 0)) && o(l.get(n)), f && o(l.get(vn)), t) {
      case"add":
        a ? f && o(l.get("length")) : (o(l.get(Mt)), Gt(e) && o(l.get(Fs)));
        break;
      case"delete":
        a || (o(l.get(Mt)), Gt(e) && o(l.get(Fs)));
        break;
      case"set":
        Gt(e) && o(l.get(Mt));
        break
    }
  }
  lr()
}

function jt(e) {
  const t = z(e);
  return t === e ? t : (Se(t, "iterate", vn), je(e) ? t : t.map(ve))
}

function us(e) {
  return Se(e = z(e), "iterate", vn), e
}

const $o = {
  __proto__: null, [Symbol.iterator]() {
    return Ts(this, Symbol.iterator, ve)
  }, concat(...e) {
    return jt(this).concat(...e.map(t => j(t) ? jt(t) : t))
  }, entries() {
    return Ts(this, "entries", e => (e[1] = ve(e[1]), e))
  }, every(e, t) {
    return ot(this, "every", e, t, void 0, arguments)
  }, filter(e, t) {
    return ot(this, "filter", e, t, n => n.map(ve), arguments)
  }, find(e, t) {
    return ot(this, "find", e, t, ve, arguments)
  }, findIndex(e, t) {
    return ot(this, "findIndex", e, t, void 0, arguments)
  }, findLast(e, t) {
    return ot(this, "findLast", e, t, ve, arguments)
  }, findLastIndex(e, t) {
    return ot(this, "findLastIndex", e, t, void 0, arguments)
  }, forEach(e, t) {
    return ot(this, "forEach", e, t, void 0, arguments)
  }, includes(...e) {
    return Ss(this, "includes", e)
  }, indexOf(...e) {
    return Ss(this, "indexOf", e)
  }, join(e) {
    return jt(this).join(e)
  }, lastIndexOf(...e) {
    return Ss(this, "lastIndexOf", e)
  }, map(e, t) {
    return ot(this, "map", e, t, void 0, arguments)
  }, pop() {
    return on(this, "pop")
  }, push(...e) {
    return on(this, "push", e)
  }, reduce(e, ...t) {
    return Fr(this, "reduce", e, t)
  }, reduceRight(e, ...t) {
    return Fr(this, "reduceRight", e, t)
  }, shift() {
    return on(this, "shift")
  }, some(e, t) {
    return ot(this, "some", e, t, void 0, arguments)
  }, splice(...e) {
    return on(this, "splice", e)
  }, toReversed() {
    return jt(this).toReversed()
  }, toSorted(e) {
    return jt(this).toSorted(e)
  }, toSpliced(...e) {
    return jt(this).toSpliced(...e)
  }, unshift(...e) {
    return on(this, "unshift", e)
  }, values() {
    return Ts(this, "values", ve)
  }
};

function Ts(e, t, n) {
  const s = us(e), r = s[t]();
  return s !== e && !je(e) && (r._next = r.next, r.next = () => {
    const i = r._next();
    return i.done || (i.value = n(i.value)), i
  }), r
}

const Uo = Array.prototype;

function ot(e, t, n, s, r, i) {
  const l = us(e), o = l !== e && !je(e), a = l[t];
  if (a !== Uo[t]) {
    const _ = a.apply(e, i);
    return o ? ve(_) : _
  }
  let f = n;
  l !== e && (o ? f = function (_, T) {
    return n.call(this, ve(_), T, e)
  } : n.length > 2 && (f = function (_, T) {
    return n.call(this, _, T, e)
  }));
  const m = a.call(l, f, s);
  return o && r ? r(m) : m
}

function Fr(e, t, n, s) {
  const r = us(e);
  let i = n;
  return r !== e && (je(e) ? n.length > 3 && (i = function (l, o, a) {
    return n.call(this, l, o, a, e)
  }) : i = function (l, o, a) {
    return n.call(this, l, ve(o), a, e)
  }), r[t](i, ...s)
}

function Ss(e, t, n) {
  const s = z(e);
  Se(s, "iterate", vn);
  const r = s[t](...n);
  return (r === -1 || r === !1) && dr(n[0]) ? (n[0] = z(n[0]), s[t](...n)) : r
}

function on(e, t, n = []) {
  _t(), ir();
  const s = z(e)[t].apply(e, n);
  return lr(), ht(), s
}

const Wo = zs("__proto__,__v_isRef,__isVue"),
  rl = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(st));

function Ho(e) {
  st(e) || (e = String(e));
  const t = z(this);
  return Se(t, "has", e), t.hasOwnProperty(e)
}

class il {
  constructor(t = !1, n = !1) {
    this._isReadonly = t, this._isShallow = n
  }

  get(t, n, s) {
    if (n === "__v_skip") return t.__v_skip;
    const r = this._isReadonly, i = this._isShallow;
    if (n === "__v_isReactive") return !r;
    if (n === "__v_isReadonly") return r;
    if (n === "__v_isShallow") return i;
    if (n === "__v_raw") return s === (r ? i ? Qo : cl : i ? al : ol).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0;
    const l = j(t);
    if (!r) {
      let a;
      if (l && (a = $o[n])) return a;
      if (n === "hasOwnProperty") return Ho
    }
    const o = Reflect.get(t, n, Ee(t) ? t : s);
    if ((st(n) ? rl.has(n) : Wo(n)) || (r || Se(t, "get", n), i)) return o;
    if (Ee(o)) {
      const a = l && nr(n) ? o : o.value;
      return r && ie(a) ? Ms(a) : a
    }
    return ie(o) ? r ? Ms(o) : ur(o) : o
  }
}

class ll extends il {
  constructor(t = !1) {
    super(!1, t)
  }

  set(t, n, s, r) {
    let i = t[n];
    if (!this._isShallow) {
      const a = Lt(i);
      if (!je(s) && !Lt(s) && (i = z(i), s = z(s)), !j(t) && Ee(i) && !Ee(s)) return a || (i.value = s), !0
    }
    const l = j(t) && nr(n) ? Number(n) < t.length : ee(t, n),
      o = Reflect.set(t, n, s, Ee(t) ? t : r);
    return t === z(r) && (l ? Tt(s, i) && ut(t, "set", n, s) : ut(t, "add", n, s)), o
  }

  deleteProperty(t, n) {
    const s = ee(t, n);
    t[n];
    const r = Reflect.deleteProperty(t, n);
    return r && s && ut(t, "delete", n, void 0), r
  }

  has(t, n) {
    const s = Reflect.has(t, n);
    return (!st(n) || !rl.has(n)) && Se(t, "has", n), s
  }

  ownKeys(t) {
    return Se(t, "iterate", j(t) ? "length" : Mt), Reflect.ownKeys(t)
  }
}

class Vo extends il {
  constructor(t = !1) {
    super(!0, t)
  }

  set(t, n) {
    return !0
  }

  deleteProperty(t, n) {
    return !0
  }
}

const jo = new ll, Ko = new Vo, Yo = new ll(!0);
const Rs = e => e, Fn = e => Reflect.getPrototypeOf(e);

function Bo(e, t, n) {
  return function (...s) {
    const r = this.__v_raw, i = z(r), l = Gt(i),
      o = e === "entries" || e === Symbol.iterator && l, a = e === "keys" && l,
      f = r[e](...s), m = n ? Rs : t ? Bn : ve;
    return !t && Se(i, "iterate", a ? Fs : Mt), {
      next() {
        const {value: _, done: T} = f.next();
        return T ? {value: _, done: T} : {
          value: o ? [m(_[0]), m(_[1])] : m(_),
          done: T
        }
      }, [Symbol.iterator]() {
        return this
      }
    }
  }
}

function Rn(e) {
  return function (...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this
  }
}

function Go(e, t) {
  const n = {
    get(r) {
      const i = this.__v_raw, l = z(i), o = z(r);
      e || (Tt(r, o) && Se(l, "get", r), Se(l, "get", o));
      const {has: a} = Fn(l), f = t ? Rs : e ? Bn : ve;
      if (a.call(l, r)) return f(i.get(r));
      if (a.call(l, o)) return f(i.get(o));
      i !== l && i.get(r)
    }, get size() {
      const r = this.__v_raw;
      return !e && Se(z(r), "iterate", Mt), r.size
    }, has(r) {
      const i = this.__v_raw, l = z(i), o = z(r);
      return e || (Tt(r, o) && Se(l, "has", r), Se(l, "has", o)), r === o ? i.has(r) : i.has(r) || i.has(o)
    }, forEach(r, i) {
      const l = this, o = l.__v_raw, a = z(o), f = t ? Rs : e ? Bn : ve;
      return !e && Se(a, "iterate", Mt), o.forEach((m, _) => r.call(i, f(m), f(_), l))
    }
  };
  return Le(n, e ? {
    add: Rn("add"),
    set: Rn("set"),
    delete: Rn("delete"),
    clear: Rn("clear")
  } : {
    add(r) {
      !t && !je(r) && !Lt(r) && (r = z(r));
      const i = z(this);
      return Fn(i).has.call(i, r) || (i.add(r), ut(i, "add", r, r)), this
    }, set(r, i) {
      !t && !je(i) && !Lt(i) && (i = z(i));
      const l = z(this), {has: o, get: a} = Fn(l);
      let f = o.call(l, r);
      f || (r = z(r), f = o.call(l, r));
      const m = a.call(l, r);
      return l.set(r, i), f ? Tt(i, m) && ut(l, "set", r, i) : ut(l, "add", r, i), this
    }, delete(r) {
      const i = z(this), {has: l, get: o} = Fn(i);
      let a = l.call(i, r);
      a || (r = z(r), a = l.call(i, r)), o && o.call(i, r);
      const f = i.delete(r);
      return a && ut(i, "delete", r, void 0), f
    }, clear() {
      const r = z(this), i = r.size !== 0, l = r.clear();
      return i && ut(r, "clear", void 0, void 0), l
    }
  }), ["keys", "values", "entries", Symbol.iterator].forEach(r => {
    n[r] = Bo(r, e, t)
  }), n
}

function cr(e, t) {
  const n = Go(e, t);
  return (s, r, i) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(ee(n, r) && r in s ? n : s, r, i)
}

const Xo = {get: cr(!1, !1)}, Jo = {get: cr(!1, !0)}, qo = {get: cr(!0, !1)};
const ol = new WeakMap, al = new WeakMap, cl = new WeakMap, Qo = new WeakMap;

function Zo(e) {
  switch (e) {
    case"Object":
    case"Array":
      return 1;
    case"Map":
    case"Set":
    case"WeakMap":
    case"WeakSet":
      return 2;
    default:
      return 0
  }
}

function zo(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Zo(So(e))
}

function ur(e) {
  return Lt(e) ? e : fr(e, !1, jo, Xo, ol)
}

function ea(e) {
  return fr(e, !1, Yo, Jo, al)
}

function Ms(e) {
  return fr(e, !0, Ko, qo, cl)
}

function fr(e, t, n, s, r) {
  if (!ie(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
  const i = zo(e);
  if (i === 0) return e;
  const l = r.get(e);
  if (l) return l;
  const o = new Proxy(e, i === 2 ? s : n);
  return r.set(e, o), o
}

function Xt(e) {
  return Lt(e) ? Xt(e.__v_raw) : !!(e && e.__v_isReactive)
}

function Lt(e) {
  return !!(e && e.__v_isReadonly)
}

function je(e) {
  return !!(e && e.__v_isShallow)
}

function dr(e) {
  return e ? !!e.__v_raw : !1
}

function z(e) {
  const t = e && e.__v_raw;
  return t ? z(t) : e
}

function ta(e) {
  return !ee(e, "__v_skip") && Object.isExtensible(e) && Yi(e, "__v_skip", !0), e
}

const ve = e => ie(e) ? ur(e) : e, Bn = e => ie(e) ? Ms(e) : e;

function Ee(e) {
  return e ? e.__v_isRef === !0 : !1
}

function kt(e) {
  return ul(e, !1)
}

function na(e) {
  return ul(e, !0)
}

function ul(e, t) {
  return Ee(e) ? e : new sa(e, t)
}

class sa {
  constructor(t, n) {
    this.dep = new ar, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : z(t), this._value = n ? t : ve(t), this.__v_isShallow = n
  }

  get value() {
    return this.dep.track(), this._value
  }

  set value(t) {
    const n = this._rawValue, s = this.__v_isShallow || je(t) || Lt(t);
    t = s ? t : z(t), Tt(t, n) && (this._rawValue = t, this._value = s ? t : ve(t), this.dep.trigger())
  }
}

function B(e) {
  return Ee(e) ? e.value : e
}

const ra = {
  get: (e, t, n) => t === "__v_raw" ? e : B(Reflect.get(e, t, n)),
  set: (e, t, n, s) => {
    const r = e[t];
    return Ee(r) && !Ee(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s)
  }
};

function fl(e) {
  return Xt(e) ? e : new Proxy(e, ra)
}

class ia {
  constructor(t, n, s) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new ar(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = yn - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s
  }

  notify() {
    if (this.flags |= 16, !(this.flags & 8) && oe !== this) return Zi(this, !0), !0
  }

  get value() {
    const t = this.dep.track();
    return tl(this), t && (t.version = this.dep.version), this._value
  }

  set value(t) {
    this.setter && this.setter(t)
  }
}

function la(e, t, n = !1) {
  let s, r;
  return K(e) ? s = e : (s = e.get, r = e.set), new ia(s, r, n)
}

const Mn = {}, Gn = new WeakMap;
let wt;

function oa(e, t = !1, n = wt) {
  if (n) {
    let s = Gn.get(n);
    s || Gn.set(n, s = []), s.push(e)
  }
}

function aa(e, t, n = re) {
  const {
    immediate: s,
    deep: r,
    once: i,
    scheduler: l,
    augmentJob: o,
    call: a
  } = n, f = E => r ? E : je(E) || r === !1 || r === 0 ? ft(E, 1) : ft(E);
  let m, _, T, x, R = !1, w = !1;
  if (Ee(e) ? (_ = () => e.value, R = je(e)) : Xt(e) ? (_ = () => f(e), R = !0) : j(e) ? (w = !0, R = e.some(E => Xt(E) || je(E)), _ = () => e.map(E => {
    if (Ee(E)) return E.value;
    if (Xt(E)) return f(E);
    if (K(E)) return a ? a(E, 2) : E()
  })) : K(e) ? t ? _ = a ? () => a(e, 2) : e : _ = () => {
    if (T) {
      _t();
      try {
        T()
      } finally {
        ht()
      }
    }
    const E = wt;
    wt = m;
    try {
      return a ? a(e, 3, [x]) : e(x)
    } finally {
      wt = E
    }
  } : _ = tt, t && r) {
    const E = _, F = r === !0 ? 1 / 0 : r;
    _ = () => ft(E(), F)
  }
  const $ = Ro(), b = () => {
    m.stop(), $ && $.active && tr($.effects, m)
  };
  if (i && t) {
    const E = t;
    t = (...F) => {
      E(...F), b()
    }
  }
  let I = w ? new Array(e.length).fill(Mn) : Mn;
  const A = E => {
    if (!(!(m.flags & 1) || !m.dirty && !E)) if (t) {
      const F = m.run();
      if (r || R || (w ? F.some((M, D) => Tt(M, I[D])) : Tt(F, I))) {
        T && T();
        const M = wt;
        wt = m;
        try {
          const D = [F, I === Mn ? void 0 : w && I[0] === Mn ? [] : I, x];
          I = F, a ? a(t, 3, D) : t(...D)
        } finally {
          wt = M
        }
      }
    } else m.run()
  };
  return o && o(A), m = new qi(_), m.scheduler = l ? () => l(A, !1) : A, x = E => oa(E, !1, m), T = m.onStop = () => {
    const E = Gn.get(m);
    if (E) {
      if (a) a(E, 4); else for (const F of E) F();
      Gn.delete(m)
    }
  }, t ? s ? A(!0) : I = m.run() : l ? l(A.bind(null, !0), !0) : m.run(), b.pause = m.pause.bind(m), b.resume = m.resume.bind(m), b.stop = b, b
}

function ft(e, t = 1 / 0, n) {
  if (t <= 0 || !ie(e) || e.__v_skip || (n = n || new Map, (n.get(e) || 0) >= t)) return e;
  if (n.set(e, t), t--, Ee(e)) ft(e.value, t, n); else if (j(e)) for (let s = 0; s < e.length; s++) ft(e[s], t, n); else if (ls(e) || Gt(e)) e.forEach(s => {
    ft(s, t, n)
  }); else if (ji(e)) {
    for (const s in e) ft(e[s], t, n);
    for (const s of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, s) && ft(e[s], t, n)
  }
  return e
}

/**
 * @vue/runtime-core v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/function On(e, t, n, s) {
  try {
    return s ? e(...s) : e()
  } catch (r) {
    fs(r, t, n)
  }
}

function rt(e, t, n, s) {
  if (K(e)) {
    const r = On(e, t, n, s);
    return r && Hi(r) && r.catch(i => {
      fs(i, t, n)
    }), r
  }
  if (j(e)) {
    const r = [];
    for (let i = 0; i < e.length; i++) r.push(rt(e[i], t, n, s));
    return r
  }
}

function fs(e, t, n, s = !0) {
  const r = t ? t.vnode : null, {
    errorHandler: i,
    throwUnhandledErrorInProduction: l
  } = t && t.appContext.config || re;
  if (t) {
    let o = t.parent;
    const a = t.proxy, f = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; o;) {
      const m = o.ec;
      if (m) {
        for (let _ = 0; _ < m.length; _++) if (m[_](e, a, f) === !1) return
      }
      o = o.parent
    }
    if (i) {
      _t(), On(i, null, 10, [e, a, f]), ht();
      return
    }
  }
  ca(e, n, r, s, l)
}

function ca(e, t, n, s = !0, r = !1) {
  if (r) throw e;
  console.error(e)
}

const xe = [];
let ze = -1;
const Jt = [];
let vt = null, Kt = 0;
const dl = Promise.resolve();
let Xn = null;

function ml(e) {
  const t = Xn || dl;
  return e ? t.then(this ? e.bind(this) : e) : t
}

function ua(e) {
  let t = ze + 1, n = xe.length;
  for (; t < n;) {
    const s = t + n >>> 1, r = xe[s], i = En(r);
    i < e || i === e && r.flags & 2 ? t = s + 1 : n = s
  }
  return t
}

function mr(e) {
  if (!(e.flags & 1)) {
    const t = En(e), n = xe[xe.length - 1];
    !n || !(e.flags & 2) && t >= En(n) ? xe.push(e) : xe.splice(ua(t), 0, e), e.flags |= 1, pl()
  }
}

function pl() {
  Xn || (Xn = dl.then(hl))
}

function fa(e) {
  j(e) ? Jt.push(...e) : vt && e.id === -1 ? vt.splice(Kt + 1, 0, e) : e.flags & 1 || (Jt.push(e), e.flags |= 1), pl()
}

function Rr(e, t, n = ze + 1) {
  for (; n < xe.length; n++) {
    const s = xe[n];
    if (s && s.flags & 2) {
      if (e && s.id !== e.uid) continue;
      xe.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2)
    }
  }
}

function _l(e) {
  if (Jt.length) {
    const t = [...new Set(Jt)].sort((n, s) => En(n) - En(s));
    if (Jt.length = 0, vt) {
      vt.push(...t);
      return
    }
    for (vt = t, Kt = 0; Kt < vt.length; Kt++) {
      const n = vt[Kt];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2
    }
    vt = null, Kt = 0
  }
}

const En = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;

function hl(e) {
  try {
    for (ze = 0; ze < xe.length; ze++) {
      const t = xe[ze];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), On(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
    }
  } finally {
    for (; ze < xe.length; ze++) {
      const t = xe[ze];
      t && (t.flags &= -2)
    }
    ze = -1, xe.length = 0, _l(), Xn = null, (xe.length || Jt.length) && hl()
  }
}

let Ve = null, gl = null;

function Jn(e) {
  const t = Ve;
  return Ve = e, gl = e && e.type.__scopeId || null, t
}

function da(e, t = Ve, n) {
  if (!t || e._n) return e;
  const s = (...r) => {
    s._d && Zn(-1);
    const i = Jn(t);
    let l;
    try {
      l = e(...r)
    } finally {
      Jn(i), s._d && Zn(1)
    }
    return l
  };
  return s._n = !0, s._c = !0, s._d = !0, s
}

function qt(e, t) {
  if (Ve === null) return e;
  const n = ps(Ve), s = e.dirs || (e.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [i, l, o, a = re] = t[r];
    i && (K(i) && (i = {
      mounted: i,
      updated: i
    }), i.deep && ft(l), s.push({
      dir: i,
      instance: n,
      value: l,
      oldValue: void 0,
      arg: o,
      modifiers: a
    }))
  }
  return e
}

function At(e, t, n, s) {
  const r = e.dirs, i = t && t.dirs;
  for (let l = 0; l < r.length; l++) {
    const o = r[l];
    i && (o.oldValue = i[l].value);
    let a = o.dir[s];
    a && (_t(), rt(a, n, 8, [e.el, o, e, t]), ht())
  }
}

const ma = Symbol("_vte"), pa = e => e.__isTeleport, _a = Symbol("_leaveCb");

function pr(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, pr(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function $e(e, t) {
  return K(e) ? Le({name: e.name}, t, {setup: e}) : e
}

function bl(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}

const qn = new WeakMap;

function pn(e, t, n, s, r = !1) {
  if (j(e)) {
    e.forEach((R, w) => pn(R, t && (j(t) ? t[w] : t), n, s, r));
    return
  }
  if (_n(s) && !r) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && pn(e, t, n, s.component.subTree);
    return
  }
  const i = s.shapeFlag & 4 ? ps(s.component) : s.el, l = r ? null : i, {
      i: o,
      r: a
    } = e, f = t && t.r, m = o.refs === re ? o.refs = {} : o.refs,
    _ = o.setupState, T = z(_), x = _ === re ? Wi : R => ee(T, R);
  if (f != null && f !== a) {
    if (Mr(t), pe(f)) m[f] = null, x(f) && (_[f] = null); else if (Ee(f)) {
      f.value = null;
      const R = t;
      R.k && (m[R.k] = null)
    }
  }
  if (K(a)) On(a, o, 12, [l, m]); else {
    const R = pe(a), w = Ee(a);
    if (R || w) {
      const $ = () => {
        if (e.f) {
          const b = R ? x(a) ? _[a] : m[a] : a.value;
          if (r) j(b) && tr(b, i); else if (j(b)) b.includes(i) || b.push(i); else if (R) m[a] = [i], x(a) && (_[a] = m[a]); else {
            const I = [i];
            a.value = I, e.k && (m[e.k] = I)
          }
        } else R ? (m[a] = l, x(a) && (_[a] = l)) : w && (a.value = l, e.k && (m[e.k] = l))
      };
      if (l) {
        const b = () => {
          $(), qn.delete(e)
        };
        b.id = -1, qn.set(e, b), Fe(b, n)
      } else Mr(e), $()
    }
  }
}

function Mr(e) {
  const t = qn.get(e);
  t && (t.flags |= 8, qn.delete(e))
}

as().requestIdleCallback;
as().cancelIdleCallback;
const _n = e => !!e.type.__asyncLoader, yl = e => e.type.__isKeepAlive;

function ha(e, t) {
  vl(e, "a", t)
}

function ga(e, t) {
  vl(e, "da", t)
}

function vl(e, t, n = Ce) {
  const s = e.__wdc || (e.__wdc = () => {
    let r = n;
    for (; r;) {
      if (r.isDeactivated) return;
      r = r.parent
    }
    return e()
  });
  if (ds(t, s, n), n) {
    let r = n.parent;
    for (; r && r.parent;) yl(r.parent.vnode) && ba(s, t, n, r), r = r.parent
  }
}

function ba(e, t, n, s) {
  const r = ds(t, e, s, !0);
  _r(() => {
    tr(s[t], r)
  }, n)
}

function ds(e, t, n = Ce, s = !1) {
  if (n) {
    const r = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...l) => {
      _t();
      const o = An(n), a = rt(t, n, e, l);
      return o(), ht(), a
    });
    return s ? r.unshift(i) : r.push(i), i
  }
}

const gt = e => (t, n = Ce) => {
    (!Sn || e === "sp") && ds(e, (...s) => t(...s), n)
  }, ya = gt("bm"), El = gt("m"), va = gt("bu"), Ea = gt("u"), Ta = gt("bum"),
  _r = gt("um"), Sa = gt("sp"), La = gt("rtg"), Ia = gt("rtc");

function xa(e, t = Ce) {
  ds("ec", e, t)
}

const Ca = Symbol.for("v-ndc");

function Tl(e, t, n, s) {
  let r;
  const i = n, l = j(e);
  if (l || pe(e)) {
    const o = l && Xt(e);
    let a = !1, f = !1;
    o && (a = !je(e), f = Lt(e), e = us(e)), r = new Array(e.length);
    for (let m = 0, _ = e.length; m < _; m++) r[m] = t(a ? f ? Bn(ve(e[m])) : ve(e[m]) : e[m], m, void 0, i)
  } else if (typeof e == "number") {
    r = new Array(e);
    for (let o = 0; o < e; o++) r[o] = t(o + 1, o, void 0, i)
  } else if (ie(e)) if (e[Symbol.iterator]) r = Array.from(e, (o, a) => t(o, a, void 0, i)); else {
    const o = Object.keys(e);
    r = new Array(o.length);
    for (let a = 0, f = o.length; a < f; a++) {
      const m = o[a];
      r[a] = t(e[m], m, a, i)
    }
  } else r = [];
  return r
}

const ks = e => e ? Vl(e) ? ps(e) : ks(e.parent) : null,
  hn = Le(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => ks(e.parent),
    $root: e => ks(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => Ll(e),
    $forceUpdate: e => e.f || (e.f = () => {
      mr(e.update)
    }),
    $nextTick: e => e.n || (e.n = ml.bind(e.proxy)),
    $watch: e => Ja.bind(e)
  }), Ls = (e, t) => e !== re && !e.__isScriptSetup && ee(e, t), Na = {
    get({_: e}, t) {
      if (t === "__v_skip") return !0;
      const {
        ctx: n,
        setupState: s,
        data: r,
        props: i,
        accessCache: l,
        type: o,
        appContext: a
      } = e;
      let f;
      if (t[0] !== "$") {
        const x = l[t];
        if (x !== void 0) switch (x) {
          case 1:
            return s[t];
          case 2:
            return r[t];
          case 4:
            return n[t];
          case 3:
            return i[t]
        } else {
          if (Ls(s, t)) return l[t] = 1, s[t];
          if (r !== re && ee(r, t)) return l[t] = 2, r[t];
          if ((f = e.propsOptions[0]) && ee(f, t)) return l[t] = 3, i[t];
          if (n !== re && ee(n, t)) return l[t] = 4, n[t];
          $s && (l[t] = 0)
        }
      }
      const m = hn[t];
      let _, T;
      if (m) return t === "$attrs" && Se(e.attrs, "get", ""), m(e);
      if ((_ = o.__cssModules) && (_ = _[t])) return _;
      if (n !== re && ee(n, t)) return l[t] = 4, n[t];
      if (T = a.config.globalProperties, ee(T, t)) return T[t]
    },
    set({_: e}, t, n) {
      const {data: s, setupState: r, ctx: i} = e;
      return Ls(r, t) ? (r[t] = n, !0) : s !== re && ee(s, t) ? (s[t] = n, !0) : ee(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0)
    },
    has({
          _: {
            data: e,
            setupState: t,
            accessCache: n,
            ctx: s,
            appContext: r,
            propsOptions: i,
            type: l
          }
        }, o) {
      let a, f;
      return !!(n[o] || e !== re && o[0] !== "$" && ee(e, o) || Ls(t, o) || (a = i[0]) && ee(a, o) || ee(s, o) || ee(hn, o) || ee(r.config.globalProperties, o) || (f = l.__cssModules) && f[o])
    },
    defineProperty(e, t, n) {
      return n.get != null ? e._.accessCache[t] = 0 : ee(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
    }
  };

function kr(e) {
  return j(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
}

let $s = !0;

function Oa(e) {
  const t = Ll(e), n = e.proxy, s = e.ctx;
  $s = !1, t.beforeCreate && $r(t.beforeCreate, e, "bc");
  const {
    data: r,
    computed: i,
    methods: l,
    watch: o,
    provide: a,
    inject: f,
    created: m,
    beforeMount: _,
    mounted: T,
    beforeUpdate: x,
    updated: R,
    activated: w,
    deactivated: $,
    beforeDestroy: b,
    beforeUnmount: I,
    destroyed: A,
    unmounted: E,
    render: F,
    renderTracked: M,
    renderTriggered: D,
    errorCaptured: X,
    serverPrefetch: te,
    expose: fe,
    inheritAttrs: be,
    components: le,
    directives: Ke,
    filters: Pt
  } = t;
  if (f && Pa(f, s, null), l) for (const se in l) {
    const Q = l[se];
    K(Q) && (s[se] = Q.bind(n))
  }
  if (r) {
    const se = r.call(n, n);
    ie(se) && (e.data = ur(se))
  }
  if ($s = !0, i) for (const se in i) {
    const Q = i[se],
      ye = K(Q) ? Q.bind(n, n) : K(Q.get) ? Q.get.bind(n, n) : tt,
      it = !K(Q) && K(Q.set) ? Q.set.bind(n) : tt, Ue = dt({get: ye, set: it});
    Object.defineProperty(s, se, {
      enumerable: !0,
      configurable: !0,
      get: () => Ue.value,
      set: Ne => Ue.value = Ne
    })
  }
  if (o) for (const se in o) Sl(o[se], s, n, se);
  if (a) {
    const se = K(a) ? a.call(n) : a;
    Reflect.ownKeys(se).forEach(Q => {
      Ma(Q, se[Q])
    })
  }
  m && $r(m, e, "c");

  function _e(se, Q) {
    j(Q) ? Q.forEach(ye => se(ye.bind(n))) : Q && se(Q.bind(n))
  }

  if (_e(ya, _), _e(El, T), _e(va, x), _e(Ea, R), _e(ha, w), _e(ga, $), _e(xa, X), _e(Ia, M), _e(La, D), _e(Ta, I), _e(_r, E), _e(Sa, te), j(fe)) if (fe.length) {
    const se = e.exposed || (e.exposed = {});
    fe.forEach(Q => {
      Object.defineProperty(se, Q, {
        get: () => n[Q],
        set: ye => n[Q] = ye,
        enumerable: !0
      })
    })
  } else e.exposed || (e.exposed = {});
  F && e.render === tt && (e.render = F), be != null && (e.inheritAttrs = be), le && (e.components = le), Ke && (e.directives = Ke), te && bl(e)
}

function Pa(e, t, n = tt) {
  j(e) && (e = Us(e));
  for (const s in e) {
    const r = e[s];
    let i;
    ie(r) ? "default" in r ? i = gn(r.from || s, r.default, !0) : i = gn(r.from || s) : i = gn(r), Ee(i) ? Object.defineProperty(t, s, {
      enumerable: !0,
      configurable: !0,
      get: () => i.value,
      set: l => i.value = l
    }) : t[s] = i
  }
}

function $r(e, t, n) {
  rt(j(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n)
}

function Sl(e, t, n, s) {
  let r = s.includes(".") ? kl(n, s) : () => n[s];
  if (pe(e)) {
    const i = t[e];
    K(i) && $t(r, i)
  } else if (K(e)) $t(r, e.bind(n)); else if (ie(e)) if (j(e)) e.forEach(i => Sl(i, t, n, s)); else {
    const i = K(e.handler) ? e.handler.bind(n) : t[e.handler];
    K(i) && $t(r, i, e)
  }
}

function Ll(e) {
  const t = e.type, {mixins: n, extends: s} = t, {
    mixins: r,
    optionsCache: i,
    config: {optionMergeStrategies: l}
  } = e.appContext, o = i.get(t);
  let a;
  return o ? a = o : !r.length && !n && !s ? a = t : (a = {}, r.length && r.forEach(f => Qn(a, f, l, !0)), Qn(a, t, l)), ie(t) && i.set(t, a), a
}

function Qn(e, t, n, s = !1) {
  const {mixins: r, extends: i} = t;
  i && Qn(e, i, n, !0), r && r.forEach(l => Qn(e, l, n, !0));
  for (const l in t) if (!(s && l === "expose")) {
    const o = Aa[l] || n && n[l];
    e[l] = o ? o(e[l], t[l]) : t[l]
  }
  return e
}

const Aa = {
  data: Ur,
  props: Wr,
  emits: Wr,
  methods: un,
  computed: un,
  beforeCreate: Ie,
  created: Ie,
  beforeMount: Ie,
  mounted: Ie,
  beforeUpdate: Ie,
  updated: Ie,
  beforeDestroy: Ie,
  beforeUnmount: Ie,
  destroyed: Ie,
  unmounted: Ie,
  activated: Ie,
  deactivated: Ie,
  errorCaptured: Ie,
  serverPrefetch: Ie,
  components: un,
  directives: un,
  watch: wa,
  provide: Ur,
  inject: Da
};

function Ur(e, t) {
  return t ? e ? function () {
    return Le(K(e) ? e.call(this, this) : e, K(t) ? t.call(this, this) : t)
  } : t : e
}

function Da(e, t) {
  return un(Us(e), Us(t))
}

function Us(e) {
  if (j(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
    return t
  }
  return e
}

function Ie(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}

function un(e, t) {
  return e ? Le(Object.create(null), e, t) : t
}

function Wr(e, t) {
  return e ? j(e) && j(t) ? [...new Set([...e, ...t])] : Le(Object.create(null), kr(e), kr(t ?? {})) : t
}

function wa(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = Le(Object.create(null), e);
  for (const s in t) n[s] = Ie(e[s], t[s]);
  return n
}

function Il() {
  return {
    app: null,
    config: {
      isNativeTag: Wi,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap,
    propsCache: new WeakMap,
    emitsCache: new WeakMap
  }
}

let Fa = 0;

function Ra(e, t) {
  return function (s, r = null) {
    K(s) || (s = Le({}, s)), r != null && !ie(r) && (r = null);
    const i = Il(), l = new WeakSet, o = [];
    let a = !1;
    const f = i.app = {
      _uid: Fa++,
      _component: s,
      _props: r,
      _container: null,
      _context: i,
      _instance: null,
      version: gc,
      get config() {
        return i.config
      },
      set config(m) {
      },
      use(m, ..._) {
        return l.has(m) || (m && K(m.install) ? (l.add(m), m.install(f, ..._)) : K(m) && (l.add(m), m(f, ..._))), f
      },
      mixin(m) {
        return i.mixins.includes(m) || i.mixins.push(m), f
      },
      component(m, _) {
        return _ ? (i.components[m] = _, f) : i.components[m]
      },
      directive(m, _) {
        return _ ? (i.directives[m] = _, f) : i.directives[m]
      },
      mount(m, _, T) {
        if (!a) {
          const x = f._ceVNode || ce(s, r);
          return x.appContext = i, T === !0 ? T = "svg" : T === !1 && (T = void 0), e(x, m, T), a = !0, f._container = m, m.__vue_app__ = f, ps(x.component)
        }
      },
      onUnmount(m) {
        o.push(m)
      },
      unmount() {
        a && (rt(o, f._instance, 16), e(null, f._container), delete f._container.__vue_app__)
      },
      provide(m, _) {
        return i.provides[m] = _, f
      },
      runWithContext(m) {
        const _ = Qt;
        Qt = f;
        try {
          return m()
        } finally {
          Qt = _
        }
      }
    };
    return f
  }
}

let Qt = null;

function Ma(e, t) {
  if (Ce) {
    let n = Ce.provides;
    const s = Ce.parent && Ce.parent.provides;
    s === n && (n = Ce.provides = Object.create(s)), n[e] = t
  }
}

function gn(e, t, n = !1) {
  const s = tn();
  if (s || Qt) {
    let r = Qt ? Qt._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (r && e in r) return r[e];
    if (arguments.length > 1) return n && K(t) ? t.call(s && s.proxy) : t
  }
}

const xl = {}, Cl = () => Object.create(xl),
  Nl = e => Object.getPrototypeOf(e) === xl;

function ka(e, t, n, s = !1) {
  const r = {}, i = Cl();
  e.propsDefaults = Object.create(null), Ol(e, t, r, i);
  for (const l in e.propsOptions[0]) l in r || (r[l] = void 0);
  n ? e.props = s ? r : ea(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i
}

function $a(e, t, n, s) {
  const {props: r, attrs: i, vnode: {patchFlag: l}} = e,
    o = z(r), [a] = e.propsOptions;
  let f = !1;
  if ((s || l > 0) && !(l & 16)) {
    if (l & 8) {
      const m = e.vnode.dynamicProps;
      for (let _ = 0; _ < m.length; _++) {
        let T = m[_];
        if (ms(e.emitsOptions, T)) continue;
        const x = t[T];
        if (a) if (ee(i, T)) x !== i[T] && (i[T] = x, f = !0); else {
          const R = St(T);
          r[R] = Ws(a, o, R, x, e, !1)
        } else x !== i[T] && (i[T] = x, f = !0)
      }
    }
  } else {
    Ol(e, t, r, i) && (f = !0);
    let m;
    for (const _ in o) (!t || !ee(t, _) && ((m = Ut(_)) === _ || !ee(t, m))) && (a ? n && (n[_] !== void 0 || n[m] !== void 0) && (r[_] = Ws(a, o, _, void 0, e, !0)) : delete r[_]);
    if (i !== o) for (const _ in i) (!t || !ee(t, _)) && (delete i[_], f = !0)
  }
  f && ut(e.attrs, "set", "")
}

function Ol(e, t, n, s) {
  const [r, i] = e.propsOptions;
  let l = !1, o;
  if (t) for (let a in t) {
    if (fn(a)) continue;
    const f = t[a];
    let m;
    r && ee(r, m = St(a)) ? !i || !i.includes(m) ? n[m] = f : (o || (o = {}))[m] = f : ms(e.emitsOptions, a) || (!(a in s) || f !== s[a]) && (s[a] = f, l = !0)
  }
  if (i) {
    const a = z(n), f = o || re;
    for (let m = 0; m < i.length; m++) {
      const _ = i[m];
      n[_] = Ws(r, a, _, f[_], e, !ee(f, _))
    }
  }
  return l
}

function Ws(e, t, n, s, r, i) {
  const l = e[n];
  if (l != null) {
    const o = ee(l, "default");
    if (o && s === void 0) {
      const a = l.default;
      if (l.type !== Function && !l.skipFactory && K(a)) {
        const {propsDefaults: f} = r;
        if (n in f) s = f[n]; else {
          const m = An(r);
          s = f[n] = a.call(null, t), m()
        }
      } else s = a;
      r.ce && r.ce._setProp(n, s)
    }
    l[0] && (i && !o ? s = !1 : l[1] && (s === "" || s === Ut(n)) && (s = !0))
  }
  return s
}

const Ua = new WeakMap;

function Pl(e, t, n = !1) {
  const s = n ? Ua : t.propsCache, r = s.get(e);
  if (r) return r;
  const i = e.props, l = {}, o = [];
  let a = !1;
  if (!K(e)) {
    const m = _ => {
      a = !0;
      const [T, x] = Pl(_, t, !0);
      Le(l, T), x && o.push(...x)
    };
    !n && t.mixins.length && t.mixins.forEach(m), e.extends && m(e.extends), e.mixins && e.mixins.forEach(m)
  }
  if (!i && !a) return ie(e) && s.set(e, Bt), Bt;
  if (j(i)) for (let m = 0; m < i.length; m++) {
    const _ = St(i[m]);
    Hr(_) && (l[_] = re)
  } else if (i) for (const m in i) {
    const _ = St(m);
    if (Hr(_)) {
      const T = i[m], x = l[_] = j(T) || K(T) ? {type: T} : Le({}, T),
        R = x.type;
      let w = !1, $ = !0;
      if (j(R)) for (let b = 0; b < R.length; ++b) {
        const I = R[b], A = K(I) && I.name;
        if (A === "Boolean") {
          w = !0;
          break
        } else A === "String" && ($ = !1)
      } else w = K(R) && R.name === "Boolean";
      x[0] = w, x[1] = $, (w || ee(x, "default")) && o.push(_)
    }
  }
  const f = [l, o];
  return ie(e) && s.set(e, f), f
}

function Hr(e) {
  return e[0] !== "$" && !fn(e)
}

const hr = e => e === "_" || e === "_ctx" || e === "$stable",
  gr = e => j(e) ? e.map(et) : [et(e)], Wa = (e, t, n) => {
    if (t._n) return t;
    const s = da((...r) => gr(t(...r)), n);
    return s._c = !1, s
  }, Al = (e, t, n) => {
    const s = e._ctx;
    for (const r in e) {
      if (hr(r)) continue;
      const i = e[r];
      if (K(i)) t[r] = Wa(r, i, s); else if (i != null) {
        const l = gr(i);
        t[r] = () => l
      }
    }
  }, Dl = (e, t) => {
    const n = gr(t);
    e.slots.default = () => n
  }, wl = (e, t, n) => {
    for (const s in t) (n || !hr(s)) && (e[s] = t[s])
  }, Ha = (e, t, n) => {
    const s = e.slots = Cl();
    if (e.vnode.shapeFlag & 32) {
      const r = t._;
      r ? (wl(s, t, n), n && Yi(s, "_", r, !0)) : Al(t, s)
    } else t && Dl(e, t)
  }, Va = (e, t, n) => {
    const {vnode: s, slots: r} = e;
    let i = !0, l = re;
    if (s.shapeFlag & 32) {
      const o = t._;
      o ? n && o === 1 ? i = !1 : wl(r, t, n) : (i = !t.$stable, Al(t, r)), l = t
    } else t && (Dl(e, t), l = {default: 1});
    if (i) for (const o in r) !hr(o) && l[o] == null && delete r[o]
  }, Fe = sc;

function ja(e) {
  return Ka(e)
}

function Ka(e, t) {
  const n = as();
  n.__VUE__ = !0;
  const {
      insert: s,
      remove: r,
      patchProp: i,
      createElement: l,
      createText: o,
      createComment: a,
      setText: f,
      setElementText: m,
      parentNode: _,
      nextSibling: T,
      setScopeId: x = tt,
      insertStaticContent: R
    } = e,
    w = (d, p, L, P = null, N = null, O = null, c = void 0, u = null, h = !!p.dynamicChildren) => {
      if (d === p) return;
      d && !an(d, p) && (P = bt(d), Ne(d, N, O, !0), d = null), p.patchFlag === -2 && (h = !1, p.dynamicChildren = null);
      const {type: v, ref: k, shapeFlag: C} = p;
      switch (v) {
        case Pn:
          $(d, p, L, P);
          break;
        case zt:
          b(d, p, L, P);
          break;
        case Hn:
          d == null && I(p, L, P, c);
          break;
        case Re:
          le(d, p, L, P, N, O, c, u, h);
          break;
        default:
          C & 1 ? F(d, p, L, P, N, O, c, u, h) : C & 6 ? Ke(d, p, L, P, N, O, c, u, h) : (C & 64 || C & 128) && v.process(d, p, L, P, N, O, c, u, h, Xe)
      }
      k != null && N ? pn(k, d && d.ref, O, p || d, !p) : k == null && d && d.ref != null && pn(d.ref, null, O, d, !0)
    }, $ = (d, p, L, P) => {
      if (d == null) s(p.el = o(p.children), L, P); else {
        const N = p.el = d.el;
        p.children !== d.children && f(N, p.children)
      }
    }, b = (d, p, L, P) => {
      d == null ? s(p.el = a(p.children || ""), L, P) : p.el = d.el
    }, I = (d, p, L, P) => {
      [d.el, d.anchor] = R(d.children, p, L, P, d.el, d.anchor)
    }, A = ({el: d, anchor: p}, L, P) => {
      let N;
      for (; d && d !== p;) N = T(d), s(d, L, P), d = N;
      s(p, L, P)
    }, E = ({el: d, anchor: p}) => {
      let L;
      for (; d && d !== p;) L = T(d), r(d), d = L;
      r(p)
    }, F = (d, p, L, P, N, O, c, u, h) => {
      p.type === "svg" ? c = "svg" : p.type === "math" && (c = "mathml"), d == null ? M(p, L, P, N, O, c, u, h) : te(d, p, N, O, c, u, h)
    }, M = (d, p, L, P, N, O, c, u) => {
      let h, v;
      const {props: k, shapeFlag: C, transition: g, dirs: S} = d;
      if (h = d.el = l(d.type, O, k && k.is, k), C & 8 ? m(h, d.children) : C & 16 && X(d.children, h, null, P, N, Is(d, O), c, u), S && At(d, null, P, "created"), D(h, d, d.scopeId, c, P), k) {
        for (const V in k) V !== "value" && !fn(V) && i(h, V, null, k[V], O, P);
        "value" in k && i(h, "value", null, k.value, O), (v = k.onVnodeBeforeMount) && qe(v, P, d)
      }
      S && At(d, null, P, "beforeMount");
      const W = Ya(N, g);
      W && g.beforeEnter(h), s(h, p, L), ((v = k && k.onVnodeMounted) || W || S) && Fe(() => {
        v && qe(v, P, d), W && g.enter(h), S && At(d, null, P, "mounted")
      }, N)
    }, D = (d, p, L, P, N) => {
      if (L && x(d, L), P) for (let O = 0; O < P.length; O++) x(d, P[O]);
      if (N) {
        let O = N.subTree;
        if (p === O || Ul(O.type) && (O.ssContent === p || O.ssFallback === p)) {
          const c = N.vnode;
          D(d, c, c.scopeId, c.slotScopeIds, N.parent)
        }
      }
    }, X = (d, p, L, P, N, O, c, u, h = 0) => {
      for (let v = h; v < d.length; v++) {
        const k = d[v] = u ? Et(d[v]) : et(d[v]);
        w(null, k, p, L, P, N, O, c, u)
      }
    }, te = (d, p, L, P, N, O, c) => {
      const u = p.el = d.el;
      let {patchFlag: h, dynamicChildren: v, dirs: k} = p;
      h |= d.patchFlag & 16;
      const C = d.props || re, g = p.props || re;
      let S;
      if (L && Dt(L, !1), (S = g.onVnodeBeforeUpdate) && qe(S, L, p, d), k && At(p, d, L, "beforeUpdate"), L && Dt(L, !0), (C.innerHTML && g.innerHTML == null || C.textContent && g.textContent == null) && m(u, ""), v ? fe(d.dynamicChildren, v, u, L, P, Is(p, N), O) : c || Q(d, p, u, null, L, P, Is(p, N), O, !1), h > 0) {
        if (h & 16) be(u, C, g, L, N); else if (h & 2 && C.class !== g.class && i(u, "class", null, g.class, N), h & 4 && i(u, "style", C.style, g.style, N), h & 8) {
          const W = p.dynamicProps;
          for (let V = 0; V < W.length; V++) {
            const Y = W[V], he = C[Y], de = g[Y];
            (de !== he || Y === "value") && i(u, Y, he, de, N, L)
          }
        }
        h & 1 && d.children !== p.children && m(u, p.children)
      } else !c && v == null && be(u, C, g, L, N);
      ((S = g.onVnodeUpdated) || k) && Fe(() => {
        S && qe(S, L, p, d), k && At(p, d, L, "updated")
      }, P)
    }, fe = (d, p, L, P, N, O, c) => {
      for (let u = 0; u < p.length; u++) {
        const h = d[u], v = p[u],
          k = h.el && (h.type === Re || !an(h, v) || h.shapeFlag & 198) ? _(h.el) : L;
        w(h, v, k, null, P, N, O, c, !0)
      }
    }, be = (d, p, L, P, N) => {
      if (p !== L) {
        if (p !== re) for (const O in p) !fn(O) && !(O in L) && i(d, O, p[O], null, N, P);
        for (const O in L) {
          if (fn(O)) continue;
          const c = L[O], u = p[O];
          c !== u && O !== "value" && i(d, O, u, c, N, P)
        }
        "value" in L && i(d, "value", p.value, L.value, N)
      }
    }, le = (d, p, L, P, N, O, c, u, h) => {
      const v = p.el = d ? d.el : o(""), k = p.anchor = d ? d.anchor : o("");
      let {patchFlag: C, dynamicChildren: g, slotScopeIds: S} = p;
      S && (u = u ? u.concat(S) : S), d == null ? (s(v, L, P), s(k, L, P), X(p.children || [], L, k, N, O, c, u, h)) : C > 0 && C & 64 && g && d.dynamicChildren ? (fe(d.dynamicChildren, g, L, N, O, c, u), (p.key != null || N && p === N.subTree) && Fl(d, p, !0)) : Q(d, p, L, k, N, O, c, u, h)
    }, Ke = (d, p, L, P, N, O, c, u, h) => {
      p.slotScopeIds = u, d == null ? p.shapeFlag & 512 ? N.ctx.activate(p, L, P, c, h) : Pt(p, L, P, N, O, c, h) : Wt(d, p, h)
    }, Pt = (d, p, L, P, N, O, c) => {
      const u = d.component = fc(d, P, N);
      if (yl(d) && (u.ctx.renderer = Xe), dc(u, !1, c), u.asyncDep) {
        if (N && N.registerDep(u, _e, c), !d.el) {
          const h = u.subTree = ce(zt);
          b(null, h, p, L), d.placeholder = h.el
        }
      } else _e(u, d, p, L, N, O, c)
    }, Wt = (d, p, L) => {
      const P = p.component = d.component;
      if (tc(d, p, L)) if (P.asyncDep && !P.asyncResolved) {
        se(P, p, L);
        return
      } else P.next = p, P.update(); else p.el = d.el, P.vnode = p
    }, _e = (d, p, L, P, N, O, c) => {
      const u = () => {
        if (d.isMounted) {
          let {next: C, bu: g, u: S, parent: W, vnode: V} = d;
          {
            const Ye = Rl(d);
            if (Ye) {
              C && (C.el = V.el, se(d, C, c)), Ye.asyncDep.then(() => {
                d.isUnmounted || u()
              });
              return
            }
          }
          let Y = C, he;
          Dt(d, !1), C ? (C.el = V.el, se(d, C, c)) : C = V, g && Wn(g), (he = C.props && C.props.onVnodeBeforeUpdate) && qe(he, W, C, V), Dt(d, !0);
          const de = jr(d), We = d.subTree;
          d.subTree = de, w(We, de, _(We.el), bt(We), d, N, O), C.el = de.el, Y === null && nc(d, de.el), S && Fe(S, N), (he = C.props && C.props.onVnodeUpdated) && Fe(() => qe(he, W, C, V), N)
        } else {
          let C;
          const {el: g, props: S} = p, {
            bm: W,
            m: V,
            parent: Y,
            root: he,
            type: de
          } = d, We = _n(p);
          Dt(d, !1), W && Wn(W), !We && (C = S && S.onVnodeBeforeMount) && qe(C, Y, p), Dt(d, !0);
          {
            he.ce && he.ce._def.shadowRoot !== !1 && he.ce._injectChildStyle(de);
            const Ye = d.subTree = jr(d);
            w(null, Ye, L, P, d, N, O), p.el = Ye.el
          }
          if (V && Fe(V, N), !We && (C = S && S.onVnodeMounted)) {
            const Ye = p;
            Fe(() => qe(C, Y, Ye), N)
          }
          (p.shapeFlag & 256 || Y && _n(Y.vnode) && Y.vnode.shapeFlag & 256) && d.a && Fe(d.a, N), d.isMounted = !0, p = L = P = null
        }
      };
      d.scope.on();
      const h = d.effect = new qi(u);
      d.scope.off();
      const v = d.update = h.run.bind(h), k = d.job = h.runIfDirty.bind(h);
      k.i = d, k.id = d.uid, h.scheduler = () => mr(k), Dt(d, !0), v()
    }, se = (d, p, L) => {
      p.component = d;
      const P = d.vnode.props;
      d.vnode = p, d.next = null, $a(d, p.props, P, L), Va(d, p.children, L), _t(), Rr(d), ht()
    }, Q = (d, p, L, P, N, O, c, u, h = !1) => {
      const v = d && d.children, k = d ? d.shapeFlag : 0,
        C = p.children, {patchFlag: g, shapeFlag: S} = p;
      if (g > 0) {
        if (g & 128) {
          it(v, C, L, P, N, O, c, u, h);
          return
        } else if (g & 256) {
          ye(v, C, L, P, N, O, c, u, h);
          return
        }
      }
      S & 8 ? (k & 16 && lt(v, N, O), C !== v && m(L, C)) : k & 16 ? S & 16 ? it(v, C, L, P, N, O, c, u, h) : lt(v, N, O, !0) : (k & 8 && m(L, ""), S & 16 && X(C, L, P, N, O, c, u, h))
    }, ye = (d, p, L, P, N, O, c, u, h) => {
      d = d || Bt, p = p || Bt;
      const v = d.length, k = p.length, C = Math.min(v, k);
      let g;
      for (g = 0; g < C; g++) {
        const S = p[g] = h ? Et(p[g]) : et(p[g]);
        w(d[g], S, L, null, N, O, c, u, h)
      }
      v > k ? lt(d, N, O, !0, !1, C) : X(p, L, P, N, O, c, u, h, C)
    }, it = (d, p, L, P, N, O, c, u, h) => {
      let v = 0;
      const k = p.length;
      let C = d.length - 1, g = k - 1;
      for (; v <= C && v <= g;) {
        const S = d[v], W = p[v] = h ? Et(p[v]) : et(p[v]);
        if (an(S, W)) w(S, W, L, null, N, O, c, u, h); else break;
        v++
      }
      for (; v <= C && v <= g;) {
        const S = d[C], W = p[g] = h ? Et(p[g]) : et(p[g]);
        if (an(S, W)) w(S, W, L, null, N, O, c, u, h); else break;
        C--, g--
      }
      if (v > C) {
        if (v <= g) {
          const S = g + 1, W = S < k ? p[S].el : P;
          for (; v <= g;) w(null, p[v] = h ? Et(p[v]) : et(p[v]), L, W, N, O, c, u, h), v++
        }
      } else if (v > g) for (; v <= C;) Ne(d[v], N, O, !0), v++; else {
        const S = v, W = v, V = new Map;
        for (v = W; v <= g; v++) {
          const we = p[v] = h ? Et(p[v]) : et(p[v]);
          we.key != null && V.set(we.key, v)
        }
        let Y, he = 0;
        const de = g - W + 1;
        let We = !1, Ye = 0;
        const ln = new Array(de);
        for (v = 0; v < de; v++) ln[v] = 0;
        for (v = S; v <= C; v++) {
          const we = d[v];
          if (he >= de) {
            Ne(we, N, O, !0);
            continue
          }
          let Je;
          if (we.key != null) Je = V.get(we.key); else for (Y = W; Y <= g; Y++) if (ln[Y - W] === 0 && an(we, p[Y])) {
            Je = Y;
            break
          }
          Je === void 0 ? Ne(we, N, O, !0) : (ln[Je - W] = v + 1, Je >= Ye ? Ye = Je : We = !0, w(we, p[Je], L, null, N, O, c, u, h), he++)
        }
        const Nr = We ? Ba(ln) : Bt;
        for (Y = Nr.length - 1, v = de - 1; v >= 0; v--) {
          const we = W + v, Je = p[we], Or = p[we + 1],
            Pr = we + 1 < k ? Or.el || Or.placeholder : P;
          ln[v] === 0 ? w(null, Je, L, Pr, N, O, c, u, h) : We && (Y < 0 || v !== Nr[Y] ? Ue(Je, L, Pr, 2) : Y--)
        }
      }
    }, Ue = (d, p, L, P, N = null) => {
      const {el: O, type: c, transition: u, children: h, shapeFlag: v} = d;
      if (v & 6) {
        Ue(d.component.subTree, p, L, P);
        return
      }
      if (v & 128) {
        d.suspense.move(p, L, P);
        return
      }
      if (v & 64) {
        c.move(d, p, L, Xe);
        return
      }
      if (c === Re) {
        s(O, p, L);
        for (let C = 0; C < h.length; C++) Ue(h[C], p, L, P);
        s(d.anchor, p, L);
        return
      }
      if (c === Hn) {
        A(d, p, L);
        return
      }
      if (P !== 2 && v & 1 && u) if (P === 0) u.beforeEnter(O), s(O, p, L), Fe(() => u.enter(O), N); else {
        const {leave: C, delayLeave: g, afterLeave: S} = u, W = () => {
          d.ctx.isUnmounted ? r(O) : s(O, p, L)
        }, V = () => {
          O._isLeaving && O[_a](!0), C(O, () => {
            W(), S && S()
          })
        };
        g ? g(O, W, V) : V()
      } else s(O, p, L)
    }, Ne = (d, p, L, P = !1, N = !1) => {
      const {
        type: O,
        props: c,
        ref: u,
        children: h,
        dynamicChildren: v,
        shapeFlag: k,
        patchFlag: C,
        dirs: g,
        cacheIndex: S
      } = d;
      if (C === -2 && (N = !1), u != null && (_t(), pn(u, null, L, d, !0), ht()), S != null && (p.renderCache[S] = void 0), k & 256) {
        p.ctx.deactivate(d);
        return
      }
      const W = k & 1 && g, V = !_n(d);
      let Y;
      if (V && (Y = c && c.onVnodeBeforeUnmount) && qe(Y, p, d), k & 6) Dn(d.component, L, P); else {
        if (k & 128) {
          d.suspense.unmount(L, P);
          return
        }
        W && At(d, null, p, "beforeUnmount"), k & 64 ? d.type.remove(d, p, L, Xe, P) : v && !v.hasOnce && (O !== Re || C > 0 && C & 64) ? lt(v, p, L, !1, !0) : (O === Re && C & 384 || !N && k & 16) && lt(h, p, L), P && Ht(d)
      }
      (V && (Y = c && c.onVnodeUnmounted) || W) && Fe(() => {
        Y && qe(Y, p, d), W && At(d, null, p, "unmounted")
      }, L)
    }, Ht = d => {
      const {type: p, el: L, anchor: P, transition: N} = d;
      if (p === Re) {
        rn(L, P);
        return
      }
      if (p === Hn) {
        E(d);
        return
      }
      const O = () => {
        r(L), N && !N.persisted && N.afterLeave && N.afterLeave()
      };
      if (d.shapeFlag & 1 && N && !N.persisted) {
        const {leave: c, delayLeave: u} = N, h = () => c(L, O);
        u ? u(d.el, O, h) : h()
      } else O()
    }, rn = (d, p) => {
      let L;
      for (; d !== p;) L = T(d), r(d), d = L;
      r(p)
    }, Dn = (d, p, L) => {
      const {bum: P, scope: N, job: O, subTree: c, um: u, m: h, a: v} = d;
      Vr(h), Vr(v), P && Wn(P), N.stop(), O && (O.flags |= 8, Ne(c, d, p, L)), u && Fe(u, p), Fe(() => {
        d.isUnmounted = !0
      }, p)
    }, lt = (d, p, L, P = !1, N = !1, O = 0) => {
      for (let c = O; c < d.length; c++) Ne(d[c], p, L, P, N)
    }, bt = d => {
      if (d.shapeFlag & 6) return bt(d.component.subTree);
      if (d.shapeFlag & 128) return d.suspense.next();
      const p = T(d.anchor || d.el), L = p && p[ma];
      return L ? T(L) : p
    };
  let yt = !1;
  const Vt = (d, p, L) => {
    d == null ? p._vnode && Ne(p._vnode, null, null, !0) : w(p._vnode || null, d, p, null, null, null, L), p._vnode = d, yt || (yt = !0, Rr(), _l(), yt = !1)
  }, Xe = {
    p: w,
    um: Ne,
    m: Ue,
    r: Ht,
    mt: Pt,
    mc: X,
    pc: Q,
    pbc: fe,
    n: bt,
    o: e
  };
  return {render: Vt, hydrate: void 0, createApp: Ra(Vt)}
}

function Is({type: e, props: t}, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}

function Dt({effect: e, job: t}, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5)
}

function Ya(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function Fl(e, t, n = !1) {
  const s = e.children, r = t.children;
  if (j(s) && j(r)) for (let i = 0; i < s.length; i++) {
    const l = s[i];
    let o = r[i];
    o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = r[i] = Et(r[i]), o.el = l.el), !n && o.patchFlag !== -2 && Fl(l, o)), o.type === Pn && o.patchFlag !== -1 && (o.el = l.el), o.type === zt && !o.el && (o.el = l.el)
  }
}

function Ba(e) {
  const t = e.slice(), n = [0];
  let s, r, i, l, o;
  const a = e.length;
  for (s = 0; s < a; s++) {
    const f = e[s];
    if (f !== 0) {
      if (r = n[n.length - 1], e[r] < f) {
        t[s] = r, n.push(s);
        continue
      }
      for (i = 0, l = n.length - 1; i < l;) o = i + l >> 1, e[n[o]] < f ? i = o + 1 : l = o;
      f < e[n[i]] && (i > 0 && (t[s] = n[i - 1]), n[i] = s)
    }
  }
  for (i = n.length, l = n[i - 1]; i-- > 0;) n[i] = l, l = t[l];
  return n
}

function Rl(e) {
  const t = e.subTree.component;
  if (t) return t.asyncDep && !t.asyncResolved ? t : Rl(t)
}

function Vr(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8
}

const Ga = Symbol.for("v-scx"), Xa = () => gn(Ga);

function $t(e, t, n) {
  return Ml(e, t, n)
}

function Ml(e, t, n = re) {
  const {immediate: s, deep: r, flush: i, once: l} = n, o = Le({}, n),
    a = t && s || !t && i !== "post";
  let f;
  if (Sn) {
    if (i === "sync") {
      const x = Xa();
      f = x.__watcherHandles || (x.__watcherHandles = [])
    } else if (!a) {
      const x = () => {
      };
      return x.stop = tt, x.resume = tt, x.pause = tt, x
    }
  }
  const m = Ce;
  o.call = (x, R, w) => rt(x, m, R, w);
  let _ = !1;
  i === "post" ? o.scheduler = x => {
    Fe(x, m && m.suspense)
  } : i !== "sync" && (_ = !0, o.scheduler = (x, R) => {
    R ? x() : mr(x)
  }), o.augmentJob = x => {
    t && (x.flags |= 4), _ && (x.flags |= 2, m && (x.id = m.uid, x.i = m))
  };
  const T = aa(e, t, o);
  return Sn && (f ? f.push(T) : a && T()), T
}

function Ja(e, t, n) {
  const s = this.proxy,
    r = pe(e) ? e.includes(".") ? kl(s, e) : () => s[e] : e.bind(s, s);
  let i;
  K(t) ? i = t : (i = t.handler, n = t);
  const l = An(this), o = Ml(r, i.bind(s), n);
  return l(), o
}

function kl(e, t) {
  const n = t.split(".");
  return () => {
    let s = e;
    for (let r = 0; r < n.length && s; r++) s = s[n[r]];
    return s
  }
}

const qa = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${St(t)}Modifiers`] || e[`${Ut(t)}Modifiers`];

function Qa(e, t, ...n) {
  if (e.isUnmounted) return;
  const s = e.vnode.props || re;
  let r = n;
  const i = t.startsWith("update:"), l = i && qa(s, t.slice(7));
  l && (l.trim && (r = n.map(m => pe(m) ? m.trim() : m)), l.number && (r = n.map(Yn)));
  let o, a = s[o = ys(t)] || s[o = ys(St(t))];
  !a && i && (a = s[o = ys(Ut(t))]), a && rt(a, e, 6, r);
  const f = s[o + "Once"];
  if (f) {
    if (!e.emitted) e.emitted = {}; else if (e.emitted[o]) return;
    e.emitted[o] = !0, rt(f, e, 6, r)
  }
}

const Za = new WeakMap;

function $l(e, t, n = !1) {
  const s = n ? Za : t.emitsCache, r = s.get(e);
  if (r !== void 0) return r;
  const i = e.emits;
  let l = {}, o = !1;
  if (!K(e)) {
    const a = f => {
      const m = $l(f, t, !0);
      m && (o = !0, Le(l, m))
    };
    !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a)
  }
  return !i && !o ? (ie(e) && s.set(e, null), null) : (j(i) ? i.forEach(a => l[a] = null) : Le(l, i), ie(e) && s.set(e, l), l)
}

function ms(e, t) {
  return !e || !is(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), ee(e, t[0].toLowerCase() + t.slice(1)) || ee(e, Ut(t)) || ee(e, t))
}

function jr(e) {
  const {
    type: t,
    vnode: n,
    proxy: s,
    withProxy: r,
    propsOptions: [i],
    slots: l,
    attrs: o,
    emit: a,
    render: f,
    renderCache: m,
    props: _,
    data: T,
    setupState: x,
    ctx: R,
    inheritAttrs: w
  } = e, $ = Jn(e);
  let b, I;
  try {
    if (n.shapeFlag & 4) {
      const E = r || s, F = E;
      b = et(f.call(F, E, m, _, x, T, R)), I = o
    } else {
      const E = t;
      b = et(E.length > 1 ? E(_, {
        attrs: o,
        slots: l,
        emit: a
      }) : E(_, null)), I = t.props ? o : za(o)
    }
  } catch (E) {
    bn.length = 0, fs(E, e, 1), b = ce(zt)
  }
  let A = b;
  if (I && w !== !1) {
    const E = Object.keys(I), {shapeFlag: F} = A;
    E.length && F & 7 && (i && E.some(er) && (I = ec(I, i)), A = en(A, I, !1, !0))
  }
  return n.dirs && (A = en(A, null, !1, !0), A.dirs = A.dirs ? A.dirs.concat(n.dirs) : n.dirs), n.transition && pr(A, n.transition), b = A, Jn($), b
}

const za = e => {
  let t;
  for (const n in e) (n === "class" || n === "style" || is(n)) && ((t || (t = {}))[n] = e[n]);
  return t
}, ec = (e, t) => {
  const n = {};
  for (const s in e) (!er(s) || !(s.slice(9) in t)) && (n[s] = e[s]);
  return n
};

function tc(e, t, n) {
  const {props: s, children: r, component: i} = e, {
    props: l,
    children: o,
    patchFlag: a
  } = t, f = i.emitsOptions;
  if (t.dirs || t.transition) return !0;
  if (n && a >= 0) {
    if (a & 1024) return !0;
    if (a & 16) return s ? Kr(s, l, f) : !!l;
    if (a & 8) {
      const m = t.dynamicProps;
      for (let _ = 0; _ < m.length; _++) {
        const T = m[_];
        if (l[T] !== s[T] && !ms(f, T)) return !0
      }
    }
  } else return (r || o) && (!o || !o.$stable) ? !0 : s === l ? !1 : s ? l ? Kr(s, l, f) : !0 : !!l;
  return !1
}

function Kr(e, t, n) {
  const s = Object.keys(t);
  if (s.length !== Object.keys(e).length) return !0;
  for (let r = 0; r < s.length; r++) {
    const i = s[r];
    if (t[i] !== e[i] && !ms(n, i)) return !0
  }
  return !1
}

function nc({vnode: e, parent: t}, n) {
  for (; t;) {
    const s = t.subTree;
    if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) (e = t.vnode).el = n, t = t.parent; else break
  }
}

const Ul = e => e.__isSuspense;

function sc(e, t) {
  t && t.pendingBranch ? j(e) ? t.effects.push(...e) : t.effects.push(e) : fa(e)
}

const Re = Symbol.for("v-fgt"), Pn = Symbol.for("v-txt"),
  zt = Symbol.for("v-cmt"), Hn = Symbol.for("v-stc"), bn = [];
let Me = null;

function Pe(e = !1) {
  bn.push(Me = e ? null : [])
}

function rc() {
  bn.pop(), Me = bn[bn.length - 1] || null
}

let Tn = 1;

function Zn(e, t = !1) {
  Tn += e, e < 0 && Me && t && (Me.hasOnce = !0)
}

function ic(e) {
  return e.dynamicChildren = Tn > 0 ? Me || Bt : null, rc(), Tn > 0 && Me && Me.push(e), e
}

function Ae(e, t, n, s, r, i) {
  return ic(y(e, t, n, s, r, i, !0))
}

function zn(e) {
  return e ? e.__v_isVNode === !0 : !1
}

function an(e, t) {
  return e.type === t.type && e.key === t.key
}

const Wl = ({key: e}) => e ?? null, Vn = ({
                                            ref: e,
                                            ref_key: t,
                                            ref_for: n
                                          }) => (typeof e == "number" && (e = "" + e), e != null ? pe(e) || Ee(e) || K(e) ? {
  i: Ve,
  r: e,
  k: t,
  f: !!n
} : e : null);

function y(e, t = null, n = null, s = 0, r = null, i = e === Re ? 0 : 1, l = !1, o = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Wl(t),
    ref: t && Vn(t),
    scopeId: gl,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: s,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Ve
  };
  return o ? (br(a, n), i & 128 && e.normalize(a)) : n && (a.shapeFlag |= pe(n) ? 8 : 16), Tn > 0 && !l && Me && (a.patchFlag > 0 || i & 6) && a.patchFlag !== 32 && Me.push(a), a
}

const ce = lc;

function lc(e, t = null, n = null, s = 0, r = null, i = !1) {
  if ((!e || e === Ca) && (e = zt), zn(e)) {
    const o = en(e, t, !0);
    return n && br(o, n), Tn > 0 && !i && Me && (o.shapeFlag & 6 ? Me[Me.indexOf(e)] = o : Me.push(o)), o.patchFlag = -2, o
  }
  if (hc(e) && (e = e.__vccOpts), t) {
    t = oc(t);
    let {class: o, style: a} = t;
    o && !pe(o) && (t.class = rr(o)), ie(a) && (dr(a) && !j(a) && (a = Le({}, a)), t.style = sr(a))
  }
  const l = pe(e) ? 1 : Ul(e) ? 128 : pa(e) ? 64 : ie(e) ? 4 : K(e) ? 2 : 0;
  return y(e, t, n, s, r, l, i, !0)
}

function oc(e) {
  return e ? dr(e) || Nl(e) ? Le({}, e) : e : null
}

function en(e, t, n = !1, s = !1) {
  const {props: r, ref: i, patchFlag: l, children: o, transition: a} = e,
    f = t ? ac(r || {}, t) : r, m = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: f,
      key: f && Wl(f),
      ref: t && t.ref ? n && i ? j(i) ? i.concat(Vn(t)) : [i, Vn(t)] : Vn(t) : i,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: o,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== Re ? l === -1 ? 16 : l | 16 : l,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: a,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && en(e.ssContent),
      ssFallback: e.ssFallback && en(e.ssFallback),
      placeholder: e.placeholder,
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
    };
  return a && s && pr(m, a.clone(m)), m
}

function It(e = " ", t = 0) {
  return ce(Pn, null, e, t)
}

function Hl(e, t) {
  const n = ce(Hn, null, e);
  return n.staticCount = t, n
}

function et(e) {
  return e == null || typeof e == "boolean" ? ce(zt) : j(e) ? ce(Re, null, e.slice()) : zn(e) ? Et(e) : ce(Pn, null, String(e))
}

function Et(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : en(e)
}

function br(e, t) {
  let n = 0;
  const {shapeFlag: s} = e;
  if (t == null) t = null; else if (j(t)) n = 16; else if (typeof t == "object") if (s & 65) {
    const r = t.default;
    r && (r._c && (r._d = !1), br(e, r()), r._c && (r._d = !0));
    return
  } else {
    n = 32;
    const r = t._;
    !r && !Nl(t) ? t._ctx = Ve : r === 3 && Ve && (Ve.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
  } else K(t) ? (t = {
    default: t,
    _ctx: Ve
  }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [It(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n
}

function ac(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    for (const r in s) if (r === "class") t.class !== s.class && (t.class = rr([t.class, s.class])); else if (r === "style") t.style = sr([t.style, s.style]); else if (is(r)) {
      const i = t[r], l = s[r];
      l && i !== l && !(j(i) && i.includes(l)) && (t[r] = i ? [].concat(i, l) : l)
    } else r !== "" && (t[r] = s[r])
  }
  return t
}

function qe(e, t, n, s = null) {
  rt(e, t, 7, [n, s])
}

const cc = Il();
let uc = 0;

function fc(e, t, n) {
  const s = e.type, r = (t ? t.appContext : e.appContext) || cc, i = {
    uid: uc++,
    vnode: e,
    type: s,
    parent: t,
    appContext: r,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    job: null,
    scope: new Ji(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(r.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: Pl(s, r),
    emitsOptions: $l(s, r),
    emit: null,
    emitted: null,
    propsDefaults: re,
    inheritAttrs: s.inheritAttrs,
    ctx: re,
    data: re,
    props: re,
    attrs: re,
    slots: re,
    refs: re,
    setupState: re,
    setupContext: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return i.ctx = {_: i}, i.root = t ? t.root : i, i.emit = Qa.bind(null, i), e.ce && e.ce(i), i
}

let Ce = null;
const tn = () => Ce || Ve;
let es, Hs;
{
  const e = as(), t = (n, s) => {
    let r;
    return (r = e[n]) || (r = e[n] = []), r.push(s), i => {
      r.length > 1 ? r.forEach(l => l(i)) : r[0](i)
    }
  };
  es = t("__VUE_INSTANCE_SETTERS__", n => Ce = n), Hs = t("__VUE_SSR_SETTERS__", n => Sn = n)
}
const An = e => {
  const t = Ce;
  return es(e), e.scope.on(), () => {
    e.scope.off(), es(t)
  }
}, Yr = () => {
  Ce && Ce.scope.off(), es(null)
};

function Vl(e) {
  return e.vnode.shapeFlag & 4
}

let Sn = !1;

function dc(e, t = !1, n = !1) {
  t && Hs(t);
  const {props: s, children: r} = e.vnode, i = Vl(e);
  ka(e, s, i, t), Ha(e, r, n || t);
  const l = i ? mc(e, t) : void 0;
  return t && Hs(!1), l
}

function mc(e, t) {
  const n = e.type;
  e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Na);
  const {setup: s} = n;
  if (s) {
    _t();
    const r = e.setupContext = s.length > 1 ? _c(e) : null, i = An(e),
      l = On(s, e, 0, [e.props, r]), o = Hi(l);
    if (ht(), i(), (o || e.sp) && !_n(e) && bl(e), o) {
      if (l.then(Yr, Yr), t) return l.then(a => {
        Br(e, a)
      }).catch(a => {
        fs(a, e, 0)
      });
      e.asyncDep = l
    } else Br(e, l)
  } else jl(e)
}

function Br(e, t, n) {
  K(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ie(t) && (e.setupState = fl(t)), jl(e)
}

function jl(e, t, n) {
  const s = e.type;
  e.render || (e.render = s.render || tt);
  {
    const r = An(e);
    _t();
    try {
      Oa(e)
    } finally {
      ht(), r()
    }
  }
}

const pc = {
  get(e, t) {
    return Se(e, "get", ""), e[t]
  }
};

function _c(e) {
  const t = n => {
    e.exposed = n || {}
  };
  return {
    attrs: new Proxy(e.attrs, pc),
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}

function ps(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(fl(ta(e.exposed)), {
    get(t, n) {
      if (n in t) return t[n];
      if (n in hn) return hn[n](e)
    }, has(t, n) {
      return n in t || n in hn
    }
  })) : e.proxy
}

function hc(e) {
  return K(e) && "__vccOpts" in e
}

const dt = (e, t) => la(e, t, Sn);

function Kl(e, t, n) {
  try {
    Zn(-1);
    const s = arguments.length;
    return s === 2 ? ie(t) && !j(t) ? zn(t) ? ce(e, null, [t]) : ce(e, t) : ce(e, null, t) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && zn(n) && (n = [n]), ce(e, t, n))
  } finally {
    Zn(1)
  }
}

const gc = "3.5.22";
/**
 * @vue/runtime-dom v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/let Vs;
const Gr = typeof window < "u" && window.trustedTypes;
if (Gr) try {
  Vs = Gr.createPolicy("vue", {createHTML: e => e})
} catch {
}
const Yl = Vs ? e => Vs.createHTML(e) : e => e,
  bc = "http://www.w3.org/2000/svg", yc = "http://www.w3.org/1998/Math/MathML",
  ct = typeof document < "u" ? document : null,
  Xr = ct && ct.createElement("template"), vc = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null)
    },
    remove: e => {
      const t = e.parentNode;
      t && t.removeChild(e)
    },
    createElement: (e, t, n, s) => {
      const r = t === "svg" ? ct.createElementNS(bc, e) : t === "mathml" ? ct.createElementNS(yc, e) : n ? ct.createElement(e, {is: n}) : ct.createElement(e);
      return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r
    },
    createText: e => ct.createTextNode(e),
    createComment: e => ct.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => ct.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, s, r, i) {
      const l = n ? n.previousSibling : t.lastChild;
      if (r && (r === i || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === i || !(r = r.nextSibling));) ; else {
        Xr.innerHTML = Yl(s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e);
        const o = Xr.content;
        if (s === "svg" || s === "mathml") {
          const a = o.firstChild;
          for (; a.firstChild;) o.appendChild(a.firstChild);
          o.removeChild(a)
        }
        t.insertBefore(o, n)
      }
      return [l ? l.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
  }, Ec = Symbol("_vtc");

function Tc(e, t, n) {
  const s = e[Ec];
  s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}

const Jr = Symbol("_vod"), Sc = Symbol("_vsh"), Lc = Symbol(""),
  Ic = /(?:^|;)\s*display\s*:/;

function xc(e, t, n) {
  const s = e.style, r = pe(n);
  let i = !1;
  if (n && !r) {
    if (t) if (pe(t)) for (const l of t.split(";")) {
      const o = l.slice(0, l.indexOf(":")).trim();
      n[o] == null && jn(s, o, "")
    } else for (const l in t) n[l] == null && jn(s, l, "");
    for (const l in n) l === "display" && (i = !0), jn(s, l, n[l])
  } else if (r) {
    if (t !== n) {
      const l = s[Lc];
      l && (n += ";" + l), s.cssText = n, i = Ic.test(n)
    }
  } else t && e.removeAttribute("style");
  Jr in e && (e[Jr] = i ? s.display : "", e[Sc] && (s.display = "none"))
}

const qr = /\s*!important$/;

function jn(e, t, n) {
  if (j(n)) n.forEach(s => jn(e, t, s)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else {
    const s = Cc(e, t);
    qr.test(n) ? e.setProperty(Ut(s), n.replace(qr, ""), "important") : e[s] = n
  }
}

const Qr = ["Webkit", "Moz", "ms"], xs = {};

function Cc(e, t) {
  const n = xs[t];
  if (n) return n;
  let s = St(t);
  if (s !== "filter" && s in e) return xs[t] = s;
  s = Ki(s);
  for (let r = 0; r < Qr.length; r++) {
    const i = Qr[r] + s;
    if (i in e) return xs[t] = i
  }
  return t
}

const Zr = "http://www.w3.org/1999/xlink";

function zr(e, t, n, s, r, i = Ao(t)) {
  s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Zr, t.slice(6, t.length)) : e.setAttributeNS(Zr, t, n) : n == null || i && !Bi(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : st(n) ? String(n) : n)
}

function ei(e, t, n, s, r) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? Yl(n) : n);
    return
  }
  const i = e.tagName;
  if (t === "value" && i !== "PROGRESS" && !i.includes("-")) {
    const o = i === "OPTION" ? e.getAttribute("value") || "" : e.value,
      a = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
    (o !== a || !("_value" in e)) && (e.value = a), n == null && e.removeAttribute(t), e._value = n;
    return
  }
  let l = !1;
  if (n === "" || n == null) {
    const o = typeof e[t];
    o === "boolean" ? n = Bi(n) : n == null && o === "string" ? (n = "", l = !0) : o === "number" && (n = 0, l = !0)
  }
  try {
    e[t] = n
  } catch {
  }
  l && e.removeAttribute(r || t)
}

function Ft(e, t, n, s) {
  e.addEventListener(t, n, s)
}

function Nc(e, t, n, s) {
  e.removeEventListener(t, n, s)
}

const ti = Symbol("_vei");

function Oc(e, t, n, s, r = null) {
  const i = e[ti] || (e[ti] = {}), l = i[t];
  if (s && l) l.value = s; else {
    const [o, a] = Pc(t);
    if (s) {
      const f = i[t] = wc(s, r);
      Ft(e, o, f, a)
    } else l && (Nc(e, o, l, a), i[t] = void 0)
  }
}

const ni = /(?:Once|Passive|Capture)$/;

function Pc(e) {
  let t;
  if (ni.test(e)) {
    t = {};
    let s;
    for (; s = e.match(ni);) e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0
  }
  return [e[2] === ":" ? e.slice(3) : Ut(e.slice(2)), t]
}

let Cs = 0;
const Ac = Promise.resolve(),
  Dc = () => Cs || (Ac.then(() => Cs = 0), Cs = Date.now());

function wc(e, t) {
  const n = s => {
    if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return;
    rt(Fc(s, n.value), t, 5, [s])
  };
  return n.value = e, n.attached = Dc(), n
}

function Fc(e, t) {
  if (j(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0
    }, t.map(s => r => !r._stopped && s && s(r))
  } else return t
}

const si = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
  Rc = (e, t, n, s, r, i) => {
    const l = r === "svg";
    t === "class" ? Tc(e, s, l) : t === "style" ? xc(e, n, s) : is(t) ? er(t) || Oc(e, t, n, s, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Mc(e, t, s, l)) ? (ei(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && zr(e, t, s, l, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !pe(s)) ? ei(e, St(t), s, i, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), zr(e, t, s, l))
  };

function Mc(e, t, n, s) {
  if (s) return !!(t === "innerHTML" || t === "textContent" || t in e && si(t) && K(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
  if (t === "width" || t === "height") {
    const r = e.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1
  }
  return si(t) && pe(n) ? !1 : t in e
}

const ts = e => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return j(t) ? n => Wn(t, n) : t
};

function kc(e) {
  e.target.composing = !0
}

function ri(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}

const Zt = Symbol("_assign"), ns = {
  created(e, {modifiers: {lazy: t, trim: n, number: s}}, r) {
    e[Zt] = ts(r);
    const i = s || r.props && r.props.type === "number";
    Ft(e, t ? "change" : "input", l => {
      if (l.target.composing) return;
      let o = e.value;
      n && (o = o.trim()), i && (o = Yn(o)), e[Zt](o)
    }), n && Ft(e, "change", () => {
      e.value = e.value.trim()
    }), t || (Ft(e, "compositionstart", kc), Ft(e, "compositionend", ri), Ft(e, "change", ri))
  },
  mounted(e, {value: t}) {
    e.value = t ?? ""
  },
  beforeUpdate(e, {
    value: t,
    oldValue: n,
    modifiers: {lazy: s, trim: r, number: i}
  }, l) {
    if (e[Zt] = ts(l), e.composing) return;
    const o = (i || e.type === "number") && !/^0\d/.test(e.value) ? Yn(e.value) : e.value,
      a = t ?? "";
    o !== a && (document.activeElement === e && e.type !== "range" && (s && t === n || r && e.value.trim() === a) || (e.value = a))
  }
}, Bl = {
  deep: !0, created(e, {value: t, modifiers: {number: n}}, s) {
    const r = ls(t);
    Ft(e, "change", () => {
      const i = Array.prototype.filter.call(e.options, l => l.selected).map(l => n ? Yn(ss(l)) : ss(l));
      e[Zt](e.multiple ? r ? new Set(i) : i : i[0]), e._assigning = !0, ml(() => {
        e._assigning = !1
      })
    }), e[Zt] = ts(s)
  }, mounted(e, {value: t}) {
    ii(e, t)
  }, beforeUpdate(e, t, n) {
    e[Zt] = ts(n)
  }, updated(e, {value: t}) {
    e._assigning || ii(e, t)
  }
};

function ii(e, t) {
  const n = e.multiple, s = j(t);
  if (!(n && !s && !ls(t))) {
    for (let r = 0, i = e.options.length; r < i; r++) {
      const l = e.options[r], o = ss(l);
      if (n) if (s) {
        const a = typeof o;
        a === "string" || a === "number" ? l.selected = t.some(f => String(f) === String(o)) : l.selected = wo(t, o) > -1
      } else l.selected = t.has(o); else if (cs(ss(l), t)) {
        e.selectedIndex !== r && (e.selectedIndex = r);
        return
      }
    }
    !n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
  }
}

function ss(e) {
  return "_value" in e ? e._value : e.value
}

const $c = Le({patchProp: Rc}, vc);
let li;

function Uc() {
  return li || (li = ja($c))
}

const Wc = ((...e) => {
  const t = Uc().createApp(...e), {mount: n} = t;
  return t.mount = s => {
    const r = Vc(s);
    if (!r) return;
    const i = t._component;
    !K(i) && !i.render && !i.template && (i.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const l = n(r, !1, Hc(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), l
  }, t
});

function Hc(e) {
  if (e instanceof SVGElement) return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function Vc(e) {
  return pe(e) ? document.querySelector(e) : e
}

const jc = {
  de: {
    App: {
      fruits: {
        apple: "kein Apfel | ein Apfel | {n} Äpfel",
        banana: "keine Banane | eine Banane | {count} Bananen",
        label: "Du hast keine {fruit} | Du hast eine {fruit} | Du hast {count} {fruit}"
      },
      fruitsLabel: "Es gibt keine Früchte | Es gibt eine Frucht | Es gibt {count} Früchte",
      menu: ["Startseite", "Über uns", "Kontakt", "Hilfe"]
    },
    Greeting: {
      greetings: "unplug-i18n-dts-generation Plugin - Demo Projekt",
      message: "Hallo TypeScript Freunde!"
    },
    InterpolationDemo: {
      birthday: "Nächstes Jahr wirst du {age}!",
      profile: "{name} ist {age} Jahre alt",
      welcome: "Willkommen, {name}!"
    },
    LanguageDropdown: {label: "Sprache:"},
    NestedKeysDemo: {
      settings: {
        notifications: {
          description: "E-Mail- und Push-Benachrichtigungen",
          label: "Benachrichtigungen"
        },
        privacy: {
          description: "Wer kann Ihre Daten sehen",
          label: "Datenschutz-Kontrollen"
        },
        theme: {
          description: "Dunkler oder heller Modus",
          label: "Design-Einstellungen"
        }
      },
      status: {
        error: "Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.",
        success: "Operation erfolgreich abgeschlossen!",
        warning: "Bitte überprüfen Sie Ihre Änderungen, bevor Sie fortfahren."
      }
    },
    PluralizationDemo: {
      cart: {status: "Ihr Warenkorb ist leer | Sie haben einen Artikel im Warenkorb | Sie haben {n} Artikel im Warenkorb"},
      explanation: {
        format: "Format: 'null | eins | viele'",
        note: "Der {n}-Wert bestimmt welche Form verwendet wird: 0=erste, 1=zweite, 2+=dritte",
        parameter: "Übergeben Sie den Parameter {n} mit dem Zählwert"
      },
      files: {uploaded: "keine Dateien hochgeladen | {n} Datei hochgeladen | {n} Dateien hochgeladen"},
      items: "keine Artikel | ein Artikel | {n} Artikel",
      messages: "keine Nachrichten | eine Nachricht | {n} Nachrichten",
      notifications: {unread: "keine ungelesenen Benachrichtigungen | eine ungelesene Benachrichtigung | {n} ungelesene Benachrichtigungen"},
      people: "niemand | {n} Person | {n} Personen",
      title: "Pluralisierungsbeispiele"
    }
  }, en: {
    App: {
      fruits: {
        apple: "apple | apples",
        banana: "banana | bananas",
        label: "You have no {fruit} | You have one {fruit} | You have {count} {fruit}"
      }, menu: ["Home", "About", "Contact", "Terms"]
    },
    FileMergingDemo: {
      description: "This component demonstrates how translation keys from multiple files are automatically merged together",
      feature: {
        autoMerge: "Files are discovered and merged automatically by the plugin",
        hotReload: "Changes to any translation file trigger hot module replacement",
        typeCheck: "All merged keys maintain full TypeScript type checking"
      },
      merged: {
        success: "Successfully merged {count} top-level translation namespaces!",
        typeSafety: "Every key has autocomplete support in your IDE"
      },
      title: "Multi-File Translation Support"
    },
    Greeting: {
      greetings: "unplug-i18n-dts-generation Plugin - Demo Project",
      message: "Hello TypeScript friends!"
    },
    InterpolationDemo: {
      birthday: "Next year you'll be {age}!",
      profile: "{name} is {age} years old",
      welcome: "Welcome, {name}!"
    },
    LanguageDropdown: {label: "Language:"},
    NestedKeysDemo: {
      settings: {
        notifications: {
          description: "Email and push alerts",
          label: "Notifications"
        },
        privacy: {
          description: "Who can see your data",
          label: "Privacy Controls"
        },
        theme: {description: "Dark or light mode", label: "Theme Settings"}
      },
      status: {
        error: "An error occurred. Please try again.",
        success: "Operation completed successfully!",
        warning: "Please review your changes before proceeding."
      }
    },
    PluralizationDemo: {
      cart: {status: "Your cart is empty | You have one item in your cart | You have {count} items in your cart"},
      explanation: {
        format: "Format: 'zero | one | many'",
        note: "The {count} value determines which form is used: 0=first, 1=second, 2+=third",
        parameter: "Pass {count} parameter matching the count value"
      },
      files: {uploaded: "no files uploaded | one file uploaded | {count} files uploaded"},
      items: "no items | one item | {count} items",
      messages: "no messages | one message | {count} message",
      notifications: {unread: "no unread notifications | one unread notification | {n} unread notifications"},
      people: "nobody | one person | {count} people",
      title: "Pluralization Examples"
    }
  }
};/*!
  * shared v11.1.12
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function Kc(e, t) {
  typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack))
}

const rs = typeof window < "u",
  xt = (e, t = !1) => t ? Symbol.for(e) : Symbol(e),
  Yc = (e, t, n) => Bc({l: e, k: t, s: n}),
  Bc = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
  me = e => typeof e == "number" && isFinite(e),
  Gc = e => yr(e) === "[object Date]", nn = e => yr(e) === "[object RegExp]",
  _s = e => G(e) && Object.keys(e).length === 0, ge = Object.assign,
  Xc = Object.create, ne = (e = null) => Xc(e);
let oi;
const Rt = () => oi || (oi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : ne());

function ai(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;")
}

function ci(e) {
  return e.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

function Jc(e) {
  return e = e.replace(/(\w+)\s*=\s*"([^"]*)"/g, (s, r, i) => `${r}="${ci(i)}"`), e = e.replace(/(\w+)\s*=\s*'([^']*)'/g, (s, r, i) => `${r}='${ci(i)}'`), /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi.test(e) && (e = e.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3")), [/(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi, /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi].forEach(s => {
    e = e.replace(s, "$1javascript&#58;")
  }), e
}

const qc = Object.prototype.hasOwnProperty;

function Be(e, t) {
  return qc.call(e, t)
}

const ue = Array.isArray, ae = e => typeof e == "function",
  U = e => typeof e == "string", J = e => typeof e == "boolean",
  q = e => e !== null && typeof e == "object",
  Qc = e => q(e) && ae(e.then) && ae(e.catch), Gl = Object.prototype.toString,
  yr = e => Gl.call(e), G = e => yr(e) === "[object Object]",
  Zc = e => e == null ? "" : ue(e) || G(e) && e.toString === Gl ? JSON.stringify(e, null, 2) : String(e);

function vr(e, t = "") {
  return e.reduce((n, s, r) => r === 0 ? n + s : n + t + s, "")
}

const kn = e => !q(e) || ue(e);

function Kn(e, t) {
  if (kn(e) || kn(t)) throw new Error("Invalid value");
  const n = [{src: e, des: t}];
  for (; n.length;) {
    const {src: s, des: r} = n.pop();
    Object.keys(s).forEach(i => {
      i !== "__proto__" && (q(s[i]) && !q(r[i]) && (r[i] = Array.isArray(s[i]) ? [] : ne()), kn(r[i]) || kn(s[i]) ? r[i] = s[i] : n.push({
        src: s[i],
        des: r[i]
      }))
    })
  }
}/*!
  * message-compiler v11.1.12
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function zc(e, t, n) {
  return {line: e, column: t, offset: n}
}

function js(e, t, n) {
  return {start: e, end: t}
}

const Z = {
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14
}, eu = 17;

function hs(e, t, n = {}) {
  const {domain: s, messages: r, args: i} = n, l = e,
    o = new SyntaxError(String(l));
  return o.code = e, t && (o.location = t), o.domain = s, o
}

function tu(e) {
  throw e
}

const Qe = " ", nu = "\r", Te = `
`, su = "\u2028", ru = "\u2029";

function iu(e) {
  const t = e;
  let n = 0, s = 1, r = 1, i = 0;
  const l = D => t[D] === nu && t[D + 1] === Te, o = D => t[D] === Te,
    a = D => t[D] === ru, f = D => t[D] === su,
    m = D => l(D) || o(D) || a(D) || f(D), _ = () => n, T = () => s,
    x = () => r, R = () => i, w = D => l(D) || a(D) || f(D) ? Te : t[D],
    $ = () => w(n), b = () => w(n + i);

  function I() {
    return i = 0, m(n) && (s++, r = 0), l(n) && n++, n++, r++, t[n]
  }

  function A() {
    return l(n + i) && i++, i++, t[n + i]
  }

  function E() {
    n = 0, s = 1, r = 1, i = 0
  }

  function F(D = 0) {
    i = D
  }

  function M() {
    const D = n + i;
    for (; D !== n;) I();
    i = 0
  }

  return {
    index: _,
    line: T,
    column: x,
    peekOffset: R,
    charAt: w,
    currentChar: $,
    currentPeek: b,
    next: I,
    peek: A,
    reset: E,
    resetPeek: F,
    skipToPeek: M
  }
}

const at = void 0, lu = ".", ui = "'", ou = "tokenizer";

function au(e, t = {}) {
  const n = t.location !== !1, s = iu(e), r = () => s.index(),
    i = () => zc(s.line(), s.column(), s.index()), l = i(), o = r(), a = {
      currentType: 13,
      offset: o,
      startLoc: l,
      endLoc: l,
      lastType: 13,
      lastOffset: o,
      lastStartLoc: l,
      lastEndLoc: l,
      braceNest: 0,
      inLinked: !1,
      text: ""
    }, f = () => a, {onError: m} = t;

  function _(c, u, h, ...v) {
    const k = f();
    if (u.column += h, u.offset += h, m) {
      const C = n ? js(k.startLoc, u) : null,
        g = hs(c, C, {domain: ou, args: v});
      m(g)
    }
  }

  function T(c, u, h) {
    c.endLoc = i(), c.currentType = u;
    const v = {type: u};
    return n && (v.loc = js(c.startLoc, c.endLoc)), h != null && (v.value = h), v
  }

  const x = c => T(c, 13);

  function R(c, u) {
    return c.currentChar() === u ? (c.next(), u) : (_(Z.EXPECTED_TOKEN, i(), 0, u), "")
  }

  function w(c) {
    let u = "";
    for (; c.currentPeek() === Qe || c.currentPeek() === Te;) u += c.currentPeek(), c.peek();
    return u
  }

  function $(c) {
    const u = w(c);
    return c.skipToPeek(), u
  }

  function b(c) {
    if (c === at) return !1;
    const u = c.charCodeAt(0);
    return u >= 97 && u <= 122 || u >= 65 && u <= 90 || u === 95
  }

  function I(c) {
    if (c === at) return !1;
    const u = c.charCodeAt(0);
    return u >= 48 && u <= 57
  }

  function A(c, u) {
    const {currentType: h} = u;
    if (h !== 2) return !1;
    w(c);
    const v = b(c.currentPeek());
    return c.resetPeek(), v
  }

  function E(c, u) {
    const {currentType: h} = u;
    if (h !== 2) return !1;
    w(c);
    const v = c.currentPeek() === "-" ? c.peek() : c.currentPeek(), k = I(v);
    return c.resetPeek(), k
  }

  function F(c, u) {
    const {currentType: h} = u;
    if (h !== 2) return !1;
    w(c);
    const v = c.currentPeek() === ui;
    return c.resetPeek(), v
  }

  function M(c, u) {
    const {currentType: h} = u;
    if (h !== 7) return !1;
    w(c);
    const v = c.currentPeek() === ".";
    return c.resetPeek(), v
  }

  function D(c, u) {
    const {currentType: h} = u;
    if (h !== 8) return !1;
    w(c);
    const v = b(c.currentPeek());
    return c.resetPeek(), v
  }

  function X(c, u) {
    const {currentType: h} = u;
    if (!(h === 7 || h === 11)) return !1;
    w(c);
    const v = c.currentPeek() === ":";
    return c.resetPeek(), v
  }

  function te(c, u) {
    const {currentType: h} = u;
    if (h !== 9) return !1;
    const v = () => {
      const C = c.currentPeek();
      return C === "{" ? b(c.peek()) : C === "@" || C === "|" || C === ":" || C === "." || C === Qe || !C ? !1 : C === Te ? (c.peek(), v()) : be(c, !1)
    }, k = v();
    return c.resetPeek(), k
  }

  function fe(c) {
    w(c);
    const u = c.currentPeek() === "|";
    return c.resetPeek(), u
  }

  function be(c, u = !0) {
    const h = (k = !1, C = "") => {
      const g = c.currentPeek();
      return g === "{" || g === "@" || !g ? k : g === "|" ? !(C === Qe || C === Te) : g === Qe ? (c.peek(), h(!0, Qe)) : g === Te ? (c.peek(), h(!0, Te)) : !0
    }, v = h();
    return u && c.resetPeek(), v
  }

  function le(c, u) {
    const h = c.currentChar();
    return h === at ? at : u(h) ? (c.next(), h) : null
  }

  function Ke(c) {
    const u = c.charCodeAt(0);
    return u >= 97 && u <= 122 || u >= 65 && u <= 90 || u >= 48 && u <= 57 || u === 95 || u === 36
  }

  function Pt(c) {
    return le(c, Ke)
  }

  function Wt(c) {
    const u = c.charCodeAt(0);
    return u >= 97 && u <= 122 || u >= 65 && u <= 90 || u >= 48 && u <= 57 || u === 95 || u === 36 || u === 45
  }

  function _e(c) {
    return le(c, Wt)
  }

  function se(c) {
    const u = c.charCodeAt(0);
    return u >= 48 && u <= 57
  }

  function Q(c) {
    return le(c, se)
  }

  function ye(c) {
    const u = c.charCodeAt(0);
    return u >= 48 && u <= 57 || u >= 65 && u <= 70 || u >= 97 && u <= 102
  }

  function it(c) {
    return le(c, ye)
  }

  function Ue(c) {
    let u = "", h = "";
    for (; u = Q(c);) h += u;
    return h
  }

  function Ne(c) {
    let u = "";
    for (; ;) {
      const h = c.currentChar();
      if (h === "{" || h === "}" || h === "@" || h === "|" || !h) break;
      if (h === Qe || h === Te) if (be(c)) u += h, c.next(); else {
        if (fe(c)) break;
        u += h, c.next()
      } else u += h, c.next()
    }
    return u
  }

  function Ht(c) {
    $(c);
    let u = "", h = "";
    for (; u = _e(c);) h += u;
    const v = c.currentChar();
    if (v && v !== "}" && v !== at && v !== Qe && v !== Te && v !== "　") {
      const k = Xe(c);
      return _(Z.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, h + k), h + k
    }
    return c.currentChar() === at && _(Z.UNTERMINATED_CLOSING_BRACE, i(), 0), h
  }

  function rn(c) {
    $(c);
    let u = "";
    return c.currentChar() === "-" ? (c.next(), u += `-${Ue(c)}`) : u += Ue(c), c.currentChar() === at && _(Z.UNTERMINATED_CLOSING_BRACE, i(), 0), u
  }

  function Dn(c) {
    return c !== ui && c !== Te
  }

  function lt(c) {
    $(c), R(c, "'");
    let u = "", h = "";
    for (; u = le(c, Dn);) u === "\\" ? h += bt(c) : h += u;
    const v = c.currentChar();
    return v === Te || v === at ? (_(Z.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0), v === Te && (c.next(), R(c, "'")), h) : (R(c, "'"), h)
  }

  function bt(c) {
    const u = c.currentChar();
    switch (u) {
      case"\\":
      case"'":
        return c.next(), `\\${u}`;
      case"u":
        return yt(c, u, 4);
      case"U":
        return yt(c, u, 6);
      default:
        return _(Z.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, u), ""
    }
  }

  function yt(c, u, h) {
    R(c, u);
    let v = "";
    for (let k = 0; k < h; k++) {
      const C = it(c);
      if (!C) {
        _(Z.INVALID_UNICODE_ESCAPE_SEQUENCE, i(), 0, `\\${u}${v}${c.currentChar()}`);
        break
      }
      v += C
    }
    return `\\${u}${v}`
  }

  function Vt(c) {
    return c !== "{" && c !== "}" && c !== Qe && c !== Te
  }

  function Xe(c) {
    $(c);
    let u = "", h = "";
    for (; u = le(c, Vt);) h += u;
    return h
  }

  function wn(c) {
    let u = "", h = "";
    for (; u = Pt(c);) h += u;
    return h
  }

  function d(c) {
    const u = h => {
      const v = c.currentChar();
      return v === "{" || v === "@" || v === "|" || v === "(" || v === ")" || !v || v === Qe ? h : (h += v, c.next(), u(h))
    };
    return u("")
  }

  function p(c) {
    $(c);
    const u = R(c, "|");
    return $(c), u
  }

  function L(c, u) {
    let h = null;
    switch (c.currentChar()) {
      case"{":
        return u.braceNest >= 1 && _(Z.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0), c.next(), h = T(u, 2, "{"), $(c), u.braceNest++, h;
      case"}":
        return u.braceNest > 0 && u.currentType === 2 && _(Z.EMPTY_PLACEHOLDER, i(), 0), c.next(), h = T(u, 3, "}"), u.braceNest--, u.braceNest > 0 && $(c), u.inLinked && u.braceNest === 0 && (u.inLinked = !1), h;
      case"@":
        return u.braceNest > 0 && _(Z.UNTERMINATED_CLOSING_BRACE, i(), 0), h = P(c, u) || x(u), u.braceNest = 0, h;
      default: {
        let k = !0, C = !0, g = !0;
        if (fe(c)) return u.braceNest > 0 && _(Z.UNTERMINATED_CLOSING_BRACE, i(), 0), h = T(u, 1, p(c)), u.braceNest = 0, u.inLinked = !1, h;
        if (u.braceNest > 0 && (u.currentType === 4 || u.currentType === 5 || u.currentType === 6)) return _(Z.UNTERMINATED_CLOSING_BRACE, i(), 0), u.braceNest = 0, N(c, u);
        if (k = A(c, u)) return h = T(u, 4, Ht(c)), $(c), h;
        if (C = E(c, u)) return h = T(u, 5, rn(c)), $(c), h;
        if (g = F(c, u)) return h = T(u, 6, lt(c)), $(c), h;
        if (!k && !C && !g) return h = T(u, 12, Xe(c)), _(Z.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, h.value), $(c), h;
        break
      }
    }
    return h
  }

  function P(c, u) {
    const {currentType: h} = u;
    let v = null;
    const k = c.currentChar();
    switch ((h === 7 || h === 8 || h === 11 || h === 9) && (k === Te || k === Qe) && _(Z.INVALID_LINKED_FORMAT, i(), 0), k) {
      case"@":
        return c.next(), v = T(u, 7, "@"), u.inLinked = !0, v;
      case".":
        return $(c), c.next(), T(u, 8, ".");
      case":":
        return $(c), c.next(), T(u, 9, ":");
      default:
        return fe(c) ? (v = T(u, 1, p(c)), u.braceNest = 0, u.inLinked = !1, v) : M(c, u) || X(c, u) ? ($(c), P(c, u)) : D(c, u) ? ($(c), T(u, 11, wn(c))) : te(c, u) ? ($(c), k === "{" ? L(c, u) || v : T(u, 10, d(c))) : (h === 7 && _(Z.INVALID_LINKED_FORMAT, i(), 0), u.braceNest = 0, u.inLinked = !1, N(c, u))
    }
  }

  function N(c, u) {
    let h = {type: 13};
    if (u.braceNest > 0) return L(c, u) || x(u);
    if (u.inLinked) return P(c, u) || x(u);
    switch (c.currentChar()) {
      case"{":
        return L(c, u) || x(u);
      case"}":
        return _(Z.UNBALANCED_CLOSING_BRACE, i(), 0), c.next(), T(u, 3, "}");
      case"@":
        return P(c, u) || x(u);
      default: {
        if (fe(c)) return h = T(u, 1, p(c)), u.braceNest = 0, u.inLinked = !1, h;
        if (be(c)) return T(u, 0, Ne(c));
        break
      }
    }
    return h
  }

  function O() {
    const {currentType: c, offset: u, startLoc: h, endLoc: v} = a;
    return a.lastType = c, a.lastOffset = u, a.lastStartLoc = h, a.lastEndLoc = v, a.offset = r(), a.startLoc = i(), s.currentChar() === at ? T(a, 13) : N(s, a)
  }

  return {nextToken: O, currentOffset: r, currentPosition: i, context: f}
}

const cu = "parser",
  uu = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function fu(e, t, n) {
  switch (e) {
    case"\\\\":
      return "\\";
    case"\\'":
      return "'";
    default: {
      const s = parseInt(t || n, 16);
      return s <= 55295 || s >= 57344 ? String.fromCodePoint(s) : "�"
    }
  }
}

function du(e = {}) {
  const t = e.location !== !1, {onError: n} = e;

  function s(b, I, A, E, ...F) {
    const M = b.currentPosition();
    if (M.offset += E, M.column += E, n) {
      const D = t ? js(A, M) : null, X = hs(I, D, {domain: cu, args: F});
      n(X)
    }
  }

  function r(b, I, A) {
    const E = {type: b};
    return t && (E.start = I, E.end = I, E.loc = {start: A, end: A}), E
  }

  function i(b, I, A, E) {
    t && (b.end = I, b.loc && (b.loc.end = A))
  }

  function l(b, I) {
    const A = b.context(), E = r(3, A.offset, A.startLoc);
    return E.value = I, i(E, b.currentOffset(), b.currentPosition()), E
  }

  function o(b, I) {
    const A = b.context(), {lastOffset: E, lastStartLoc: F} = A, M = r(5, E, F);
    return M.index = parseInt(I, 10), b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
  }

  function a(b, I) {
    const A = b.context(), {lastOffset: E, lastStartLoc: F} = A, M = r(4, E, F);
    return M.key = I, b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
  }

  function f(b, I) {
    const A = b.context(), {lastOffset: E, lastStartLoc: F} = A, M = r(9, E, F);
    return M.value = I.replace(uu, fu), b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
  }

  function m(b) {
    const I = b.nextToken(), A = b.context(), {
      lastOffset: E,
      lastStartLoc: F
    } = A, M = r(8, E, F);
    return I.type !== 11 ? (s(b, Z.UNEXPECTED_EMPTY_LINKED_MODIFIER, A.lastStartLoc, 0), M.value = "", i(M, E, F), {
      nextConsumeToken: I,
      node: M
    }) : (I.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, A.lastStartLoc, 0, Ze(I)), M.value = I.value || "", i(M, b.currentOffset(), b.currentPosition()), {node: M})
  }

  function _(b, I) {
    const A = b.context(), E = r(7, A.offset, A.startLoc);
    return E.value = I, i(E, b.currentOffset(), b.currentPosition()), E
  }

  function T(b) {
    const I = b.context(), A = r(6, I.offset, I.startLoc);
    let E = b.nextToken();
    if (E.type === 8) {
      const F = m(b);
      A.modifier = F.node, E = F.nextConsumeToken || b.nextToken()
    }
    switch (E.type !== 9 && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(E)), E = b.nextToken(), E.type === 2 && (E = b.nextToken()), E.type) {
      case 10:
        E.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(E)), A.key = _(b, E.value || "");
        break;
      case 4:
        E.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(E)), A.key = a(b, E.value || "");
        break;
      case 5:
        E.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(E)), A.key = o(b, E.value || "");
        break;
      case 6:
        E.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(E)), A.key = f(b, E.value || "");
        break;
      default: {
        s(b, Z.UNEXPECTED_EMPTY_LINKED_KEY, I.lastStartLoc, 0);
        const F = b.context(), M = r(7, F.offset, F.startLoc);
        return M.value = "", i(M, F.offset, F.startLoc), A.key = M, i(A, F.offset, F.startLoc), {
          nextConsumeToken: E,
          node: A
        }
      }
    }
    return i(A, b.currentOffset(), b.currentPosition()), {node: A}
  }

  function x(b) {
    const I = b.context(),
      A = I.currentType === 1 ? b.currentOffset() : I.offset,
      E = I.currentType === 1 ? I.endLoc : I.startLoc, F = r(2, A, E);
    F.items = [];
    let M = null;
    do {
      const te = M || b.nextToken();
      switch (M = null, te.type) {
        case 0:
          te.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(te)), F.items.push(l(b, te.value || ""));
          break;
        case 5:
          te.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(te)), F.items.push(o(b, te.value || ""));
          break;
        case 4:
          te.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(te)), F.items.push(a(b, te.value || ""));
          break;
        case 6:
          te.value == null && s(b, Z.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Ze(te)), F.items.push(f(b, te.value || ""));
          break;
        case 7: {
          const fe = T(b);
          F.items.push(fe.node), M = fe.nextConsumeToken || null;
          break
        }
      }
    } while (I.currentType !== 13 && I.currentType !== 1);
    const D = I.currentType === 1 ? I.lastOffset : b.currentOffset(),
      X = I.currentType === 1 ? I.lastEndLoc : b.currentPosition();
    return i(F, D, X), F
  }

  function R(b, I, A, E) {
    const F = b.context();
    let M = E.items.length === 0;
    const D = r(1, I, A);
    D.cases = [], D.cases.push(E);
    do {
      const X = x(b);
      M || (M = X.items.length === 0), D.cases.push(X)
    } while (F.currentType !== 13);
    return M && s(b, Z.MUST_HAVE_MESSAGES_IN_PLURAL, A, 0), i(D, b.currentOffset(), b.currentPosition()), D
  }

  function w(b) {
    const I = b.context(), {offset: A, startLoc: E} = I, F = x(b);
    return I.currentType === 13 ? F : R(b, A, E, F)
  }

  function $(b) {
    const I = au(b, ge({}, e)), A = I.context(), E = r(0, A.offset, A.startLoc);
    return t && E.loc && (E.loc.source = b), E.body = w(I), e.onCacheKey && (E.cacheKey = e.onCacheKey(b)), A.currentType !== 13 && s(I, Z.UNEXPECTED_LEXICAL_ANALYSIS, A.lastStartLoc, 0, b[A.offset] || ""), i(E, I.currentOffset(), I.currentPosition()), E
  }

  return {parse: $}
}

function Ze(e) {
  if (e.type === 13) return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "…" : t
}

function mu(e, t = {}) {
  const n = {ast: e, helpers: new Set};
  return {context: () => n, helper: i => (n.helpers.add(i), i)}
}

function fi(e, t) {
  for (let n = 0; n < e.length; n++) Er(e[n], t)
}

function Er(e, t) {
  switch (e.type) {
    case 1:
      fi(e.cases, t), t.helper("plural");
      break;
    case 2:
      fi(e.items, t);
      break;
    case 6: {
      Er(e.key, t), t.helper("linked"), t.helper("type");
      break
    }
    case 5:
      t.helper("interpolate"), t.helper("list");
      break;
    case 4:
      t.helper("interpolate"), t.helper("named");
      break
  }
}

function pu(e, t = {}) {
  const n = mu(e);
  n.helper("normalize"), e.body && Er(e.body, n);
  const s = n.context();
  e.helpers = Array.from(s.helpers)
}

function _u(e) {
  const t = e.body;
  return t.type === 2 ? di(t) : t.cases.forEach(n => di(n)), e
}

function di(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value)
  } else {
    const t = [];
    for (let n = 0; n < e.items.length; n++) {
      const s = e.items[n];
      if (!(s.type === 3 || s.type === 9) || s.value == null) break;
      t.push(s.value)
    }
    if (t.length === e.items.length) {
      e.static = vr(t);
      for (let n = 0; n < e.items.length; n++) {
        const s = e.items[n];
        (s.type === 3 || s.type === 9) && delete s.value
      }
    }
  }
}

function Yt(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      Yt(t.body), t.b = t.body, delete t.body;
      break
    }
    case 1: {
      const t = e, n = t.cases;
      for (let s = 0; s < n.length; s++) Yt(n[s]);
      t.c = n, delete t.cases;
      break
    }
    case 2: {
      const t = e, n = t.items;
      for (let s = 0; s < n.length; s++) Yt(n[s]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break
    }
    case 6: {
      const t = e;
      Yt(t.key), t.k = t.key, delete t.key, t.modifier && (Yt(t.modifier), t.m = t.modifier, delete t.modifier);
      break
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break
    }
  }
  delete e.type
}

function hu(e, t) {
  const {filename: n, breakLineCode: s, needIndent: r} = t,
    i = t.location !== !1, l = {
      filename: n,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: s,
      needIndent: r,
      indentLevel: 0
    };
  i && e.loc && (l.source = e.loc.source);
  const o = () => l;

  function a(w, $) {
    l.code += w
  }

  function f(w, $ = !0) {
    const b = $ ? s : "";
    a(r ? b + "  ".repeat(w) : b)
  }

  function m(w = !0) {
    const $ = ++l.indentLevel;
    w && f($)
  }

  function _(w = !0) {
    const $ = --l.indentLevel;
    w && f($)
  }

  function T() {
    f(l.indentLevel)
  }

  return {
    context: o,
    push: a,
    indent: m,
    deindent: _,
    newline: T,
    helper: w => `_${w}`,
    needIndent: () => l.needIndent
  }
}

function gu(e, t) {
  const {helper: n} = e;
  e.push(`${n("linked")}(`), sn(e, t.key), t.modifier ? (e.push(", "), sn(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")")
}

function bu(e, t) {
  const {helper: n, needIndent: s} = e;
  e.push(`${n("normalize")}([`), e.indent(s());
  const r = t.items.length;
  for (let i = 0; i < r && (sn(e, t.items[i]), i !== r - 1); i++) e.push(", ");
  e.deindent(s()), e.push("])")
}

function yu(e, t) {
  const {helper: n, needIndent: s} = e;
  if (t.cases.length > 1) {
    e.push(`${n("plural")}([`), e.indent(s());
    const r = t.cases.length;
    for (let i = 0; i < r && (sn(e, t.cases[i]), i !== r - 1); i++) e.push(", ");
    e.deindent(s()), e.push("])")
  }
}

function vu(e, t) {
  t.body ? sn(e, t.body) : e.push("null")
}

function sn(e, t) {
  const {helper: n} = e;
  switch (t.type) {
    case 0:
      vu(e, t);
      break;
    case 1:
      yu(e, t);
      break;
    case 2:
      bu(e, t);
      break;
    case 6:
      gu(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break
  }
}

const Eu = (e, t = {}) => {
  const n = U(t.mode) ? t.mode : "normal",
    s = U(t.filename) ? t.filename : "message.intl";
  t.sourceMap;
  const r = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`, i = t.needIndent ? t.needIndent : n !== "arrow", l = e.helpers || [],
    o = hu(e, {filename: s, breakLineCode: r, needIndent: i});
  o.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), o.indent(i), l.length > 0 && (o.push(`const { ${vr(l.map(m => `${m}: _${m}`), ", ")} } = ctx`), o.newline()), o.push("return "), sn(o, e), o.deindent(i), o.push("}"), delete e.helpers;
  const {code: a, map: f} = o.context();
  return {ast: e, code: a, map: f ? f.toJSON() : void 0}
};

function Tu(e, t = {}) {
  const n = ge({}, t), s = !!n.jit, r = !!n.minify,
    i = n.optimize == null ? !0 : n.optimize, o = du(n).parse(e);
  return s ? (i && _u(o), r && Yt(o), {ast: o, code: ""}) : (pu(o, n), Eu(o, n))
}/*!
  * core-base v11.1.12
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function Su() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Rt().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Rt().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1)
}

function nt(e) {
  return q(e) && Tr(e) === 0 && (Be(e, "b") || Be(e, "body"))
}

const Xl = ["b", "body"];

function Lu(e) {
  return Ct(e, Xl)
}

const Jl = ["c", "cases"];

function Iu(e) {
  return Ct(e, Jl, [])
}

const ql = ["s", "static"];

function xu(e) {
  return Ct(e, ql)
}

const Ql = ["i", "items"];

function Cu(e) {
  return Ct(e, Ql, [])
}

const Zl = ["t", "type"];

function Tr(e) {
  return Ct(e, Zl)
}

const zl = ["v", "value"];

function $n(e, t) {
  const n = Ct(e, zl);
  if (n != null) return n;
  throw Ln(t)
}

const eo = ["m", "modifier"];

function Nu(e) {
  return Ct(e, eo)
}

const to = ["k", "key"];

function Ou(e) {
  const t = Ct(e, to);
  if (t) return t;
  throw Ln(6)
}

function Ct(e, t, n) {
  for (let s = 0; s < t.length; s++) {
    const r = t[s];
    if (Be(e, r) && e[r] != null) return e[r]
  }
  return n
}

const no = [...Xl, ...Jl, ...ql, ...Ql, ...to, ...eo, ...zl, ...Zl];

function Ln(e) {
  return new Error(`unhandled node type: ${e}`)
}

function Ns(e) {
  return n => Pu(n, e)
}

function Pu(e, t) {
  const n = Lu(t);
  if (n == null) throw Ln(0);
  if (Tr(n) === 1) {
    const i = Iu(n);
    return e.plural(i.reduce((l, o) => [...l, mi(e, o)], []))
  } else return mi(e, n)
}

function mi(e, t) {
  const n = xu(t);
  if (n != null) return e.type === "text" ? n : e.normalize([n]);
  {
    const s = Cu(t).reduce((r, i) => [...r, Ks(e, i)], []);
    return e.normalize(s)
  }
}

function Ks(e, t) {
  const n = Tr(t);
  switch (n) {
    case 3:
      return $n(t, n);
    case 9:
      return $n(t, n);
    case 4: {
      const s = t;
      if (Be(s, "k") && s.k) return e.interpolate(e.named(s.k));
      if (Be(s, "key") && s.key) return e.interpolate(e.named(s.key));
      throw Ln(n)
    }
    case 5: {
      const s = t;
      if (Be(s, "i") && me(s.i)) return e.interpolate(e.list(s.i));
      if (Be(s, "index") && me(s.index)) return e.interpolate(e.list(s.index));
      throw Ln(n)
    }
    case 6: {
      const s = t, r = Nu(s), i = Ou(s);
      return e.linked(Ks(e, i), r ? Ks(e, r) : void 0, e.type)
    }
    case 7:
      return $n(t, n);
    case 8:
      return $n(t, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`)
  }
}

const Au = e => e;
let Un = ne();

function Du(e, t = {}) {
  let n = !1;
  const s = t.onError || tu;
  return t.onError = r => {
    n = !0, s(r)
  }, {...Tu(e, t), detectError: n}
}

function wu(e, t) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && U(e)) {
    J(t.warnHtmlMessage) && t.warnHtmlMessage;
    const s = (t.onCacheKey || Au)(e), r = Un[s];
    if (r) return r;
    const {ast: i, detectError: l} = Du(e, {...t, location: !1, jit: !0}),
      o = Ns(i);
    return l ? o : Un[s] = o
  } else {
    const n = e.cacheKey;
    if (n) {
      const s = Un[n];
      return s || (Un[n] = Ns(e))
    } else return Ns(e)
  }
}

let In = null;

function Fu(e) {
  In = e
}

function Ru(e, t, n) {
  In && In.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: n
  })
}

const Mu = ku("function:translate");

function ku(e) {
  return t => In && In.emit(e, t)
}

const mt = {
  INVALID_ARGUMENT: eu,
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
}, $u = 24;

function pt(e) {
  return hs(e, null, void 0)
}

function Sr(e, t) {
  return t.locale != null ? pi(t.locale) : pi(e.locale)
}

let Os;

function pi(e) {
  if (U(e)) return e;
  if (ae(e)) {
    if (e.resolvedOnce && Os != null) return Os;
    if (e.constructor.name === "Function") {
      const t = e();
      if (Qc(t)) throw pt(mt.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return Os = t
    } else throw pt(mt.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
  } else throw pt(mt.NOT_SUPPORT_LOCALE_TYPE)
}

function Uu(e, t, n) {
  return [...new Set([n, ...ue(t) ? t : q(t) ? Object.keys(t) : U(t) ? [t] : [n]])]
}

function so(e, t, n) {
  const s = U(n) ? n : xn, r = e;
  r.__localeChainCache || (r.__localeChainCache = new Map);
  let i = r.__localeChainCache.get(s);
  if (!i) {
    i = [];
    let l = [n];
    for (; ue(l);) l = _i(i, l, t);
    const o = ue(t) || !G(t) ? t : t.default ? t.default : null;
    l = U(o) ? [o] : o, ue(l) && _i(i, l, !1), r.__localeChainCache.set(s, i)
  }
  return i
}

function _i(e, t, n) {
  let s = !0;
  for (let r = 0; r < t.length && J(s); r++) {
    const i = t[r];
    U(i) && (s = Wu(e, t[r], n))
  }
  return s
}

function Wu(e, t, n) {
  let s;
  const r = t.split("-");
  do {
    const i = r.join("-");
    s = Hu(e, i, n), r.splice(-1, 1)
  } while (r.length && s === !0);
  return s
}

function Hu(e, t, n) {
  let s = !1;
  if (!e.includes(t) && (s = !0, t)) {
    s = t[t.length - 1] !== "!";
    const r = t.replace(/!/g, "");
    e.push(r), (ue(n) || G(n)) && n[r] && (s = n[r])
  }
  return s
}

const Nt = [];
Nt[0] = {w: [0], i: [3, 0], "[": [4], o: [7]};
Nt[1] = {w: [1], ".": [2], "[": [4], o: [7]};
Nt[2] = {w: [2], i: [3, 0], 0: [3, 0]};
Nt[3] = {i: [3, 0], 0: [3, 0], w: [1, 1], ".": [2, 1], "[": [4, 1], o: [7, 1]};
Nt[4] = {"'": [5, 0], '"': [6, 0], "[": [4, 2], "]": [1, 3], o: 8, l: [4, 0]};
Nt[5] = {"'": [4, 0], o: 8, l: [5, 0]};
Nt[6] = {'"': [4, 0], o: 8, l: [6, 0]};
const Vu = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function ju(e) {
  return Vu.test(e)
}

function Ku(e) {
  const t = e.charCodeAt(0), n = e.charCodeAt(e.length - 1);
  return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e
}

function Yu(e) {
  if (e == null) return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w"
  }
  return "i"
}

function Bu(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : ju(t) ? Ku(t) : "*" + t
}

function Gu(e) {
  const t = [];
  let n = -1, s = 0, r = 0, i, l, o, a, f, m, _;
  const T = [];
  T[0] = () => {
    l === void 0 ? l = o : l += o
  }, T[1] = () => {
    l !== void 0 && (t.push(l), l = void 0)
  }, T[2] = () => {
    T[0](), r++
  }, T[3] = () => {
    if (r > 0) r--, s = 4, T[0](); else {
      if (r = 0, l === void 0 || (l = Bu(l), l === !1)) return !1;
      T[1]()
    }
  };

  function x() {
    const R = e[n + 1];
    if (s === 5 && R === "'" || s === 6 && R === '"') return n++, o = "\\" + R, T[0](), !0
  }

  for (; s !== null;) if (n++, i = e[n], !(i === "\\" && x())) {
    if (a = Yu(i), _ = Nt[s], f = _[a] || _.l || 8, f === 8 || (s = f[0], f[1] !== void 0 && (m = T[f[1]], m && (o = i, m() === !1)))) return;
    if (s === 7) return t
  }
}

const hi = new Map;

function Xu(e, t) {
  return q(e) ? e[t] : null
}

function Ju(e, t) {
  if (!q(e)) return null;
  let n = hi.get(t);
  if (n || (n = Gu(t), n && hi.set(t, n)), !n) return null;
  const s = n.length;
  let r = e, i = 0;
  for (; i < s;) {
    const l = n[i];
    if (no.includes(l) && nt(r)) return null;
    const o = r[l];
    if (o === void 0 || ae(r)) return null;
    r = o, i++
  }
  return r
}

const qu = "11.1.12", gs = -1, xn = "en-US", gi = "",
  bi = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;

function Qu() {
  return {
    upper: (e, t) => t === "text" && U(e) ? e.toUpperCase() : t === "vnode" && q(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && U(e) ? e.toLowerCase() : t === "vnode" && q(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && U(e) ? bi(e) : t === "vnode" && q(e) && "__v_isVNode" in e ? bi(e.children) : e
  }
}

let ro;

function Zu(e) {
  ro = e
}

let io;

function zu(e) {
  io = e
}

let lo;

function ef(e) {
  lo = e
}

let oo = null;
const tf = e => {
  oo = e
}, nf = () => oo;
let ao = null;
const yi = e => {
  ao = e
}, sf = () => ao;
let vi = 0;

function rf(e = {}) {
  const t = ae(e.onWarn) ? e.onWarn : Kc, n = U(e.version) ? e.version : qu,
    s = U(e.locale) || ae(e.locale) ? e.locale : xn, r = ae(s) ? xn : s,
    i = ue(e.fallbackLocale) || G(e.fallbackLocale) || U(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : r,
    l = G(e.messages) ? e.messages : Ps(r),
    o = G(e.datetimeFormats) ? e.datetimeFormats : Ps(r),
    a = G(e.numberFormats) ? e.numberFormats : Ps(r),
    f = ge(ne(), e.modifiers, Qu()), m = e.pluralRules || ne(),
    _ = ae(e.missing) ? e.missing : null,
    T = J(e.missingWarn) || nn(e.missingWarn) ? e.missingWarn : !0,
    x = J(e.fallbackWarn) || nn(e.fallbackWarn) ? e.fallbackWarn : !0,
    R = !!e.fallbackFormat, w = !!e.unresolving,
    $ = ae(e.postTranslation) ? e.postTranslation : null,
    b = G(e.processor) ? e.processor : null,
    I = J(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, A = !!e.escapeParameter,
    E = ae(e.messageCompiler) ? e.messageCompiler : ro,
    F = ae(e.messageResolver) ? e.messageResolver : io || Xu,
    M = ae(e.localeFallbacker) ? e.localeFallbacker : lo || Uu,
    D = q(e.fallbackContext) ? e.fallbackContext : void 0, X = e,
    te = q(X.__datetimeFormatters) ? X.__datetimeFormatters : new Map,
    fe = q(X.__numberFormatters) ? X.__numberFormatters : new Map,
    be = q(X.__meta) ? X.__meta : {};
  vi++;
  const le = {
    version: n,
    cid: vi,
    locale: s,
    fallbackLocale: i,
    messages: l,
    modifiers: f,
    pluralRules: m,
    missing: _,
    missingWarn: T,
    fallbackWarn: x,
    fallbackFormat: R,
    unresolving: w,
    postTranslation: $,
    processor: b,
    warnHtmlMessage: I,
    escapeParameter: A,
    messageCompiler: E,
    messageResolver: F,
    localeFallbacker: M,
    fallbackContext: D,
    onWarn: t,
    __meta: be
  };
  return le.datetimeFormats = o, le.numberFormats = a, le.__datetimeFormatters = te, le.__numberFormatters = fe, __INTLIFY_PROD_DEVTOOLS__ && Ru(le, n, be), le
}

const Ps = e => ({[e]: ne()});

function Lr(e, t, n, s, r) {
  const {missing: i, onWarn: l} = e;
  if (i !== null) {
    const o = i(e, n, t, r);
    return U(o) ? o : t
  } else return t
}

function cn(e, t, n) {
  const s = e;
  s.__localeChainCache = new Map, e.localeFallbacker(e, n, t)
}

function lf(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0]
}

function of(e, t) {
  const n = t.indexOf(e);
  if (n === -1) return !1;
  for (let s = n + 1; s < t.length; s++) if (lf(e, t[s])) return !0;
  return !1
}

function Ei(e, ...t) {
  const {
      datetimeFormats: n,
      unresolving: s,
      fallbackLocale: r,
      onWarn: i,
      localeFallbacker: l
    } = e, {__datetimeFormatters: o} = e, [a, f, m, _] = Ys(...t),
    T = J(m.missingWarn) ? m.missingWarn : e.missingWarn;
  J(m.fallbackWarn) ? m.fallbackWarn : e.fallbackWarn;
  const x = !!m.part, R = Sr(e, m), w = l(e, r, R);
  if (!U(a) || a === "") return new Intl.DateTimeFormat(R, _).format(f);
  let $ = {}, b, I = null;
  const A = "datetime format";
  for (let M = 0; M < w.length && (b = w[M], $ = n[b] || {}, I = $[a], !G(I)); M++) Lr(e, a, b, T, A);
  if (!G(I) || !U(b)) return s ? gs : a;
  let E = `${b}__${a}`;
  _s(_) || (E = `${E}__${JSON.stringify(_)}`);
  let F = o.get(E);
  return F || (F = new Intl.DateTimeFormat(b, ge({}, I, _)), o.set(E, F)), x ? F.formatToParts(f) : F.format(f)
}

const co = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function Ys(...e) {
  const [t, n, s, r] = e, i = ne();
  let l = ne(), o;
  if (U(t)) {
    const a = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!a) throw pt(mt.INVALID_ISO_DATE_ARGUMENT);
    const f = a[3] ? a[3].trim().startsWith("T") ? `${a[1].trim()}${a[3].trim()}` : `${a[1].trim()}T${a[3].trim()}` : a[1].trim();
    o = new Date(f);
    try {
      o.toISOString()
    } catch {
      throw pt(mt.INVALID_ISO_DATE_ARGUMENT)
    }
  } else if (Gc(t)) {
    if (isNaN(t.getTime())) throw pt(mt.INVALID_DATE_ARGUMENT);
    o = t
  } else if (me(t)) o = t; else throw pt(mt.INVALID_ARGUMENT);
  return U(n) ? i.key = n : G(n) && Object.keys(n).forEach(a => {
    co.includes(a) ? l[a] = n[a] : i[a] = n[a]
  }), U(s) ? i.locale = s : G(s) && (l = s), G(r) && (l = r), [i.key || "", o, i, l]
}

function Ti(e, t, n) {
  const s = e;
  for (const r in n) {
    const i = `${t}__${r}`;
    s.__datetimeFormatters.has(i) && s.__datetimeFormatters.delete(i)
  }
}

function Si(e, ...t) {
  const {
      numberFormats: n,
      unresolving: s,
      fallbackLocale: r,
      onWarn: i,
      localeFallbacker: l
    } = e, {__numberFormatters: o} = e, [a, f, m, _] = Bs(...t),
    T = J(m.missingWarn) ? m.missingWarn : e.missingWarn;
  J(m.fallbackWarn) ? m.fallbackWarn : e.fallbackWarn;
  const x = !!m.part, R = Sr(e, m), w = l(e, r, R);
  if (!U(a) || a === "") return new Intl.NumberFormat(R, _).format(f);
  let $ = {}, b, I = null;
  const A = "number format";
  for (let M = 0; M < w.length && (b = w[M], $ = n[b] || {}, I = $[a], !G(I)); M++) Lr(e, a, b, T, A);
  if (!G(I) || !U(b)) return s ? gs : a;
  let E = `${b}__${a}`;
  _s(_) || (E = `${E}__${JSON.stringify(_)}`);
  let F = o.get(E);
  return F || (F = new Intl.NumberFormat(b, ge({}, I, _)), o.set(E, F)), x ? F.formatToParts(f) : F.format(f)
}

const uo = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function Bs(...e) {
  const [t, n, s, r] = e, i = ne();
  let l = ne();
  if (!me(t)) throw pt(mt.INVALID_ARGUMENT);
  const o = t;
  return U(n) ? i.key = n : G(n) && Object.keys(n).forEach(a => {
    uo.includes(a) ? l[a] = n[a] : i[a] = n[a]
  }), U(s) ? i.locale = s : G(s) && (l = s), G(r) && (l = r), [i.key || "", o, i, l]
}

function Li(e, t, n) {
  const s = e;
  for (const r in n) {
    const i = `${t}__${r}`;
    s.__numberFormatters.has(i) && s.__numberFormatters.delete(i)
  }
}

const af = e => e, cf = e => "", uf = "text",
  ff = e => e.length === 0 ? "" : vr(e), df = Zc;

function Ii(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}

function mf(e) {
  const t = me(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (me(e.named.count) || me(e.named.n)) ? me(e.named.count) ? e.named.count : me(e.named.n) ? e.named.n : t : t
}

function pf(e, t) {
  t.count || (t.count = e), t.n || (t.n = e)
}

function _f(e = {}) {
  const t = e.locale, n = mf(e),
    s = q(e.pluralRules) && U(t) && ae(e.pluralRules[t]) ? e.pluralRules[t] : Ii,
    r = q(e.pluralRules) && U(t) && ae(e.pluralRules[t]) ? Ii : void 0,
    i = b => b[s(n, b.length, r)], l = e.list || [], o = b => l[b],
    a = e.named || ne();
  me(e.pluralIndex) && pf(n, a);
  const f = b => a[b];

  function m(b, I) {
    const A = ae(e.messages) ? e.messages(b, !!I) : q(e.messages) ? e.messages[b] : !1;
    return A || (e.parent ? e.parent.message(b) : cf)
  }

  const _ = b => e.modifiers ? e.modifiers[b] : af,
    T = G(e.processor) && ae(e.processor.normalize) ? e.processor.normalize : ff,
    x = G(e.processor) && ae(e.processor.interpolate) ? e.processor.interpolate : df,
    R = G(e.processor) && U(e.processor.type) ? e.processor.type : uf, $ = {
      list: o,
      named: f,
      plural: i,
      linked: (b, ...I) => {
        const [A, E] = I;
        let F = "text", M = "";
        I.length === 1 ? q(A) ? (M = A.modifier || M, F = A.type || F) : U(A) && (M = A || M) : I.length === 2 && (U(A) && (M = A || M), U(E) && (F = E || F));
        const D = m(b, !0)($), X = F === "vnode" && ue(D) && M ? D[0] : D;
        return M ? _(M)(X, F) : X
      },
      message: m,
      type: R,
      interpolate: x,
      normalize: T,
      values: ge(ne(), l, a)
    };
  return $
}

const xi = () => "", He = e => ae(e);

function Ci(e, ...t) {
  const {
      fallbackFormat: n,
      postTranslation: s,
      unresolving: r,
      messageCompiler: i,
      fallbackLocale: l,
      messages: o
    } = e, [a, f] = Gs(...t),
    m = J(f.missingWarn) ? f.missingWarn : e.missingWarn,
    _ = J(f.fallbackWarn) ? f.fallbackWarn : e.fallbackWarn,
    T = J(f.escapeParameter) ? f.escapeParameter : e.escapeParameter,
    x = !!f.resolvedMessage,
    R = U(f.default) || J(f.default) ? J(f.default) ? i ? a : () => a : f.default : n ? i ? a : () => a : null,
    w = n || R != null && (U(R) || ae(R)), $ = Sr(e, f);
  T && hf(f);
  let [b, I, A] = x ? [a, $, o[$] || ne()] : fo(e, a, $, l, _, m), E = b, F = a;
  if (!x && !(U(E) || nt(E) || He(E)) && w && (E = R, F = E), !x && (!(U(E) || nt(E) || He(E)) || !U(I))) return r ? gs : a;
  let M = !1;
  const D = () => {
    M = !0
  }, X = He(E) ? E : mo(e, a, I, E, F, D);
  if (M) return E;
  const te = yf(e, I, A, f), fe = _f(te), be = gf(e, X, fe);
  let le = s ? s(be, a) : be;
  if (T && U(le) && (le = Jc(le)), __INTLIFY_PROD_DEVTOOLS__) {
    const Ke = {
      timestamp: Date.now(),
      key: U(a) ? a : He(E) ? E.key : "",
      locale: I || (He(E) ? E.locale : ""),
      format: U(E) ? E : He(E) ? E.source : "",
      message: le
    };
    Ke.meta = ge({}, e.__meta, nf() || {}), Mu(Ke)
  }
  return le
}

function hf(e) {
  ue(e.list) ? e.list = e.list.map(t => U(t) ? ai(t) : t) : q(e.named) && Object.keys(e.named).forEach(t => {
    U(e.named[t]) && (e.named[t] = ai(e.named[t]))
  })
}

function fo(e, t, n, s, r, i) {
  const {messages: l, onWarn: o, messageResolver: a, localeFallbacker: f} = e,
    m = f(e, s, n);
  let _ = ne(), T, x = null;
  const R = "translate";
  for (let w = 0; w < m.length && (T = m[w], _ = l[T] || ne(), (x = a(_, t)) === null && (x = _[t]), !(U(x) || nt(x) || He(x))); w++) if (!of(T, m)) {
    const $ = Lr(e, t, T, i, R);
    $ !== t && (x = $)
  }
  return [x, T, _]
}

function mo(e, t, n, s, r, i) {
  const {messageCompiler: l, warnHtmlMessage: o} = e;
  if (He(s)) {
    const f = s;
    return f.locale = f.locale || n, f.key = f.key || t, f
  }
  if (l == null) {
    const f = (() => s);
    return f.locale = n, f.key = t, f
  }
  const a = l(s, bf(e, n, r, s, o, i));
  return a.locale = n, a.key = t, a.source = s, a
}

function gf(e, t, n) {
  return t(n)
}

function Gs(...e) {
  const [t, n, s] = e, r = ne();
  if (!U(t) && !me(t) && !He(t) && !nt(t)) throw pt(mt.INVALID_ARGUMENT);
  const i = me(t) ? String(t) : (He(t), t);
  return me(n) ? r.plural = n : U(n) ? r.default = n : G(n) && !_s(n) ? r.named = n : ue(n) && (r.list = n), me(s) ? r.plural = s : U(s) ? r.default = s : G(s) && ge(r, s), [i, r]
}

function bf(e, t, n, s, r, i) {
  return {
    locale: t, key: n, warnHtmlMessage: r, onError: l => {
      throw i && i(l), l
    }, onCacheKey: l => Yc(t, n, l)
  }
}

function yf(e, t, n, s) {
  const {
    modifiers: r,
    pluralRules: i,
    messageResolver: l,
    fallbackLocale: o,
    fallbackWarn: a,
    missingWarn: f,
    fallbackContext: m
  } = e, T = {
    locale: t, modifiers: r, pluralRules: i, messages: (x, R) => {
      let w = l(n, x);
      if (w == null && (m || R)) {
        const [, , $] = fo(m || e, x, t, o, a, f);
        w = l($, x)
      }
      if (U(w) || nt(w)) {
        let $ = !1;
        const I = mo(e, x, t, w, x, () => {
          $ = !0
        });
        return $ ? xi : I
      } else return He(w) ? w : xi
    }
  };
  return e.processor && (T.processor = e.processor), s.list && (T.list = s.list), s.named && (T.named = s.named), me(s.plural) && (T.pluralIndex = s.plural), T
}

Su();/*!
  * vue-i18n v11.1.12
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const vf = "11.1.12";

function Ef() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Rt().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Rt().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Rt().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Rt().__INTLIFY_PROD_DEVTOOLS__ = !1)
}

const De = {
  UNEXPECTED_RETURN_TYPE: $u,
  INVALID_ARGUMENT: 25,
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  UNEXPECTED_ERROR: 32
};

function ke(e, ...t) {
  return hs(e, null, void 0)
}

const Xs = xt("__translateVNode"), Js = xt("__datetimeParts"),
  qs = xt("__numberParts"), po = xt("__setPluralRules"),
  _o = xt("__injectWithOption"), Qs = xt("__dispose");

function Cn(e) {
  if (!q(e) || nt(e)) return e;
  for (const t in e) if (Be(e, t)) if (!t.includes(".")) q(e[t]) && Cn(e[t]); else {
    const n = t.split("."), s = n.length - 1;
    let r = e, i = !1;
    for (let l = 0; l < s; l++) {
      if (n[l] === "__proto__") throw new Error(`unsafe key: ${n[l]}`);
      if (n[l] in r || (r[n[l]] = ne()), !q(r[n[l]])) {
        i = !0;
        break
      }
      r = r[n[l]]
    }
    if (i || (nt(r) ? no.includes(n[s]) || delete e[t] : (r[n[s]] = e[t], delete e[t])), !nt(r)) {
      const l = r[n[s]];
      q(l) && Cn(l)
    }
  }
  return e
}

function Ir(e, t) {
  const {messages: n, __i18n: s, messageResolver: r, flatJson: i} = t,
    l = G(n) ? n : ue(s) ? ne() : {[e]: ne()};
  if (ue(s) && s.forEach(o => {
    if ("locale" in o && "resource" in o) {
      const {locale: a, resource: f} = o;
      a ? (l[a] = l[a] || ne(), Kn(f, l[a])) : Kn(f, l)
    } else U(o) && Kn(JSON.parse(o), l)
  }), r == null && i) for (const o in l) Be(l, o) && Cn(l[o]);
  return l
}

function ho(e) {
  return e.type
}

function go(e, t, n) {
  let s = q(t.messages) ? t.messages : ne();
  "__i18nGlobal" in n && (s = Ir(e.locale.value, {
    messages: s,
    __i18n: n.__i18nGlobal
  }));
  const r = Object.keys(s);
  r.length && r.forEach(i => {
    e.mergeLocaleMessage(i, s[i])
  });
  {
    if (q(t.datetimeFormats)) {
      const i = Object.keys(t.datetimeFormats);
      i.length && i.forEach(l => {
        e.mergeDateTimeFormat(l, t.datetimeFormats[l])
      })
    }
    if (q(t.numberFormats)) {
      const i = Object.keys(t.numberFormats);
      i.length && i.forEach(l => {
        e.mergeNumberFormat(l, t.numberFormats[l])
      })
    }
  }
}

function Ni(e) {
  return ce(Pn, null, e, 0)
}

const Oi = "__INTLIFY_META__", Pi = () => [], Tf = () => !1;
let Ai = 0;

function Di(e) {
  return ((t, n, s, r) => e(n, s, tn() || void 0, r))
}

const Sf = () => {
  const e = tn();
  let t = null;
  return e && (t = ho(e)[Oi]) ? {[Oi]: t} : null
};

function xr(e = {}) {
  const {__root: t, __injectWithOption: n} = e, s = t === void 0,
    r = e.flatJson, i = rs ? kt : na;
  let l = J(e.inheritLocale) ? e.inheritLocale : !0;
  const o = i(t && l ? t.locale.value : U(e.locale) ? e.locale : xn),
    a = i(t && l ? t.fallbackLocale.value : U(e.fallbackLocale) || ue(e.fallbackLocale) || G(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : o.value),
    f = i(Ir(o.value, e)),
    m = i(G(e.datetimeFormats) ? e.datetimeFormats : {[o.value]: {}}),
    _ = i(G(e.numberFormats) ? e.numberFormats : {[o.value]: {}});
  let T = t ? t.missingWarn : J(e.missingWarn) || nn(e.missingWarn) ? e.missingWarn : !0,
    x = t ? t.fallbackWarn : J(e.fallbackWarn) || nn(e.fallbackWarn) ? e.fallbackWarn : !0,
    R = t ? t.fallbackRoot : J(e.fallbackRoot) ? e.fallbackRoot : !0,
    w = !!e.fallbackFormat, $ = ae(e.missing) ? e.missing : null,
    b = ae(e.missing) ? Di(e.missing) : null,
    I = ae(e.postTranslation) ? e.postTranslation : null,
    A = t ? t.warnHtmlMessage : J(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
    E = !!e.escapeParameter;
  const F = t ? t.modifiers : G(e.modifiers) ? e.modifiers : {};
  let M = e.pluralRules || t && t.pluralRules, D;
  D = (() => {
    s && yi(null);
    const g = {
      version: vf,
      locale: o.value,
      fallbackLocale: a.value,
      messages: f.value,
      modifiers: F,
      pluralRules: M,
      missing: b === null ? void 0 : b,
      missingWarn: T,
      fallbackWarn: x,
      fallbackFormat: w,
      unresolving: !0,
      postTranslation: I === null ? void 0 : I,
      warnHtmlMessage: A,
      escapeParameter: E,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: {framework: "vue"}
    };
    g.datetimeFormats = m.value, g.numberFormats = _.value, g.__datetimeFormatters = G(D) ? D.__datetimeFormatters : void 0, g.__numberFormatters = G(D) ? D.__numberFormatters : void 0;
    const S = rf(g);
    return s && yi(S), S
  })(), cn(D, o.value, a.value);

  function te() {
    return [o.value, a.value, f.value, m.value, _.value]
  }

  const fe = dt({
    get: () => o.value, set: g => {
      D.locale = g, o.value = g
    }
  }), be = dt({
    get: () => a.value, set: g => {
      D.fallbackLocale = g, a.value = g, cn(D, o.value, g)
    }
  }), le = dt(() => f.value), Ke = dt(() => m.value), Pt = dt(() => _.value);

  function Wt() {
    return ae(I) ? I : null
  }

  function _e(g) {
    I = g, D.postTranslation = g
  }

  function se() {
    return $
  }

  function Q(g) {
    g !== null && (b = Di(g)), $ = g, D.missing = b
  }

  const ye = (g, S, W, V, Y, he) => {
    te();
    let de;
    try {
      __INTLIFY_PROD_DEVTOOLS__, s || (D.fallbackContext = t ? sf() : void 0), de = g(D)
    } finally {
      __INTLIFY_PROD_DEVTOOLS__, s || (D.fallbackContext = void 0)
    }
    if (W !== "translate exists" && me(de) && de === gs || W === "translate exists" && !de) {
      const [We, Ye] = S();
      return t && R ? V(t) : Y(We)
    } else {
      if (he(de)) return de;
      throw ke(De.UNEXPECTED_RETURN_TYPE)
    }
  };

  function it(...g) {
    return ye(S => Reflect.apply(Ci, null, [S, ...g]), () => Gs(...g), "translate", S => Reflect.apply(S.t, S, [...g]), S => S, S => U(S))
  }

  function Ue(...g) {
    const [S, W, V] = g;
    if (V && !q(V)) throw ke(De.INVALID_ARGUMENT);
    return it(S, W, ge({resolvedMessage: !0}, V || {}))
  }

  function Ne(...g) {
    return ye(S => Reflect.apply(Ei, null, [S, ...g]), () => Ys(...g), "datetime format", S => Reflect.apply(S.d, S, [...g]), () => gi, S => U(S) || ue(S))
  }

  function Ht(...g) {
    return ye(S => Reflect.apply(Si, null, [S, ...g]), () => Bs(...g), "number format", S => Reflect.apply(S.n, S, [...g]), () => gi, S => U(S) || ue(S))
  }

  function rn(g) {
    return g.map(S => U(S) || me(S) || J(S) ? Ni(String(S)) : S)
  }

  const lt = {normalize: rn, interpolate: g => g, type: "vnode"};

  function bt(...g) {
    return ye(S => {
      let W;
      const V = S;
      try {
        V.processor = lt, W = Reflect.apply(Ci, null, [V, ...g])
      } finally {
        V.processor = null
      }
      return W
    }, () => Gs(...g), "translate", S => S[Xs](...g), S => [Ni(S)], S => ue(S))
  }

  function yt(...g) {
    return ye(S => Reflect.apply(Si, null, [S, ...g]), () => Bs(...g), "number format", S => S[qs](...g), Pi, S => U(S) || ue(S))
  }

  function Vt(...g) {
    return ye(S => Reflect.apply(Ei, null, [S, ...g]), () => Ys(...g), "datetime format", S => S[Js](...g), Pi, S => U(S) || ue(S))
  }

  function Xe(g) {
    M = g, D.pluralRules = M
  }

  function wn(g, S) {
    return ye(() => {
      if (!g) return !1;
      const W = U(S) ? S : o.value, V = L(W), Y = D.messageResolver(V, g);
      return nt(Y) || He(Y) || U(Y)
    }, () => [g], "translate exists", W => Reflect.apply(W.te, W, [g, S]), Tf, W => J(W))
  }

  function d(g) {
    let S = null;
    const W = so(D, a.value, o.value);
    for (let V = 0; V < W.length; V++) {
      const Y = f.value[W[V]] || {}, he = D.messageResolver(Y, g);
      if (he != null) {
        S = he;
        break
      }
    }
    return S
  }

  function p(g) {
    const S = d(g);
    return S ?? (t ? t.tm(g) || {} : {})
  }

  function L(g) {
    return f.value[g] || {}
  }

  function P(g, S) {
    if (r) {
      const W = {[g]: S};
      for (const V in W) Be(W, V) && Cn(W[V]);
      S = W[g]
    }
    f.value[g] = S, D.messages = f.value
  }

  function N(g, S) {
    f.value[g] = f.value[g] || {};
    const W = {[g]: S};
    if (r) for (const V in W) Be(W, V) && Cn(W[V]);
    S = W[g], Kn(S, f.value[g]), D.messages = f.value
  }

  function O(g) {
    return m.value[g] || {}
  }

  function c(g, S) {
    m.value[g] = S, D.datetimeFormats = m.value, Ti(D, g, S)
  }

  function u(g, S) {
    m.value[g] = ge(m.value[g] || {}, S), D.datetimeFormats = m.value, Ti(D, g, S)
  }

  function h(g) {
    return _.value[g] || {}
  }

  function v(g, S) {
    _.value[g] = S, D.numberFormats = _.value, Li(D, g, S)
  }

  function k(g, S) {
    _.value[g] = ge(_.value[g] || {}, S), D.numberFormats = _.value, Li(D, g, S)
  }

  Ai++, t && rs && ($t(t.locale, g => {
    l && (o.value = g, D.locale = g, cn(D, o.value, a.value))
  }), $t(t.fallbackLocale, g => {
    l && (a.value = g, D.fallbackLocale = g, cn(D, o.value, a.value))
  }));
  const C = {
    id: Ai,
    locale: fe,
    fallbackLocale: be,
    get inheritLocale() {
      return l
    },
    set inheritLocale(g) {
      l = g, g && t && (o.value = t.locale.value, a.value = t.fallbackLocale.value, cn(D, o.value, a.value))
    },
    get availableLocales() {
      return Object.keys(f.value).sort()
    },
    messages: le,
    get modifiers() {
      return F
    },
    get pluralRules() {
      return M || {}
    },
    get isGlobal() {
      return s
    },
    get missingWarn() {
      return T
    },
    set missingWarn(g) {
      T = g, D.missingWarn = T
    },
    get fallbackWarn() {
      return x
    },
    set fallbackWarn(g) {
      x = g, D.fallbackWarn = x
    },
    get fallbackRoot() {
      return R
    },
    set fallbackRoot(g) {
      R = g
    },
    get fallbackFormat() {
      return w
    },
    set fallbackFormat(g) {
      w = g, D.fallbackFormat = w
    },
    get warnHtmlMessage() {
      return A
    },
    set warnHtmlMessage(g) {
      A = g, D.warnHtmlMessage = g
    },
    get escapeParameter() {
      return E
    },
    set escapeParameter(g) {
      E = g, D.escapeParameter = g
    },
    t: it,
    getLocaleMessage: L,
    setLocaleMessage: P,
    mergeLocaleMessage: N,
    getPostTranslationHandler: Wt,
    setPostTranslationHandler: _e,
    getMissingHandler: se,
    setMissingHandler: Q,
    [po]: Xe
  };
  return C.datetimeFormats = Ke, C.numberFormats = Pt, C.rt = Ue, C.te = wn, C.tm = p, C.d = Ne, C.n = Ht, C.getDateTimeFormat = O, C.setDateTimeFormat = c, C.mergeDateTimeFormat = u, C.getNumberFormat = h, C.setNumberFormat = v, C.mergeNumberFormat = k, C[_o] = n, C[Xs] = bt, C[Js] = Vt, C[qs] = yt, C
}

function Lf(e) {
  const t = U(e.locale) ? e.locale : xn,
    n = U(e.fallbackLocale) || ue(e.fallbackLocale) || G(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : t,
    s = ae(e.missing) ? e.missing : void 0,
    r = J(e.silentTranslationWarn) || nn(e.silentTranslationWarn) ? !e.silentTranslationWarn : !0,
    i = J(e.silentFallbackWarn) || nn(e.silentFallbackWarn) ? !e.silentFallbackWarn : !0,
    l = J(e.fallbackRoot) ? e.fallbackRoot : !0, o = !!e.formatFallbackMessages,
    a = G(e.modifiers) ? e.modifiers : {}, f = e.pluralizationRules,
    m = ae(e.postTranslation) ? e.postTranslation : void 0,
    _ = U(e.warnHtmlInMessage) ? e.warnHtmlInMessage !== "off" : !0,
    T = !!e.escapeParameterHtml, x = J(e.sync) ? e.sync : !0;
  let R = e.messages;
  if (G(e.sharedMessages)) {
    const F = e.sharedMessages;
    R = Object.keys(F).reduce((D, X) => {
      const te = D[X] || (D[X] = {});
      return ge(te, F[X]), D
    }, R || {})
  }
  const {__i18n: w, __root: $, __injectWithOption: b} = e,
    I = e.datetimeFormats, A = e.numberFormats, E = e.flatJson;
  return {
    locale: t,
    fallbackLocale: n,
    messages: R,
    flatJson: E,
    datetimeFormats: I,
    numberFormats: A,
    missing: s,
    missingWarn: r,
    fallbackWarn: i,
    fallbackRoot: l,
    fallbackFormat: o,
    modifiers: a,
    pluralRules: f,
    postTranslation: m,
    warnHtmlMessage: _,
    escapeParameter: T,
    messageResolver: e.messageResolver,
    inheritLocale: x,
    __i18n: w,
    __root: $,
    __injectWithOption: b
  }
}

function Zs(e = {}) {
  const t = xr(Lf(e)), {__extender: n} = e, s = {
    id: t.id, get locale() {
      return t.locale.value
    }, set locale(r) {
      t.locale.value = r
    }, get fallbackLocale() {
      return t.fallbackLocale.value
    }, set fallbackLocale(r) {
      t.fallbackLocale.value = r
    }, get messages() {
      return t.messages.value
    }, get datetimeFormats() {
      return t.datetimeFormats.value
    }, get numberFormats() {
      return t.numberFormats.value
    }, get availableLocales() {
      return t.availableLocales
    }, get missing() {
      return t.getMissingHandler()
    }, set missing(r) {
      t.setMissingHandler(r)
    }, get silentTranslationWarn() {
      return J(t.missingWarn) ? !t.missingWarn : t.missingWarn
    }, set silentTranslationWarn(r) {
      t.missingWarn = J(r) ? !r : r
    }, get silentFallbackWarn() {
      return J(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn
    }, set silentFallbackWarn(r) {
      t.fallbackWarn = J(r) ? !r : r
    }, get modifiers() {
      return t.modifiers
    }, get formatFallbackMessages() {
      return t.fallbackFormat
    }, set formatFallbackMessages(r) {
      t.fallbackFormat = r
    }, get postTranslation() {
      return t.getPostTranslationHandler()
    }, set postTranslation(r) {
      t.setPostTranslationHandler(r)
    }, get sync() {
      return t.inheritLocale
    }, set sync(r) {
      t.inheritLocale = r
    }, get warnHtmlInMessage() {
      return t.warnHtmlMessage ? "warn" : "off"
    }, set warnHtmlInMessage(r) {
      t.warnHtmlMessage = r !== "off"
    }, get escapeParameterHtml() {
      return t.escapeParameter
    }, set escapeParameterHtml(r) {
      t.escapeParameter = r
    }, get pluralizationRules() {
      return t.pluralRules || {}
    }, __composer: t, t(...r) {
      return Reflect.apply(t.t, t, [...r])
    }, rt(...r) {
      return Reflect.apply(t.rt, t, [...r])
    }, te(r, i) {
      return t.te(r, i)
    }, tm(r) {
      return t.tm(r)
    }, getLocaleMessage(r) {
      return t.getLocaleMessage(r)
    }, setLocaleMessage(r, i) {
      t.setLocaleMessage(r, i)
    }, mergeLocaleMessage(r, i) {
      t.mergeLocaleMessage(r, i)
    }, d(...r) {
      return Reflect.apply(t.d, t, [...r])
    }, getDateTimeFormat(r) {
      return t.getDateTimeFormat(r)
    }, setDateTimeFormat(r, i) {
      t.setDateTimeFormat(r, i)
    }, mergeDateTimeFormat(r, i) {
      t.mergeDateTimeFormat(r, i)
    }, n(...r) {
      return Reflect.apply(t.n, t, [...r])
    }, getNumberFormat(r) {
      return t.getNumberFormat(r)
    }, setNumberFormat(r, i) {
      t.setNumberFormat(r, i)
    }, mergeNumberFormat(r, i) {
      t.mergeNumberFormat(r, i)
    }
  };
  return s.__extender = n, s
}

function If(e, t, n) {
  return {
    beforeCreate() {
      const s = tn();
      if (!s) throw ke(De.UNEXPECTED_ERROR);
      const r = this.$options;
      if (r.i18n) {
        const i = r.i18n;
        if (r.__i18n && (i.__i18n = r.__i18n), i.__root = t, this === this.$root) this.$i18n = wi(e, i); else {
          i.__injectWithOption = !0, i.__extender = n.__vueI18nExtend, this.$i18n = Zs(i);
          const l = this.$i18n;
          l.__extender && (l.__disposer = l.__extender(this.$i18n))
        }
      } else if (r.__i18n) if (this === this.$root) this.$i18n = wi(e, r); else {
        this.$i18n = Zs({
          __i18n: r.__i18n,
          __injectWithOption: !0,
          __extender: n.__vueI18nExtend,
          __root: t
        });
        const i = this.$i18n;
        i.__extender && (i.__disposer = i.__extender(this.$i18n))
      } else this.$i18n = e;
      r.__i18nGlobal && go(t, r, r), this.$t = (...i) => this.$i18n.t(...i), this.$rt = (...i) => this.$i18n.rt(...i), this.$te = (i, l) => this.$i18n.te(i, l), this.$d = (...i) => this.$i18n.d(...i), this.$n = (...i) => this.$i18n.n(...i), this.$tm = i => this.$i18n.tm(i), n.__setInstance(s, this.$i18n)
    }, mounted() {
    }, unmounted() {
      const s = tn();
      if (!s) throw ke(De.UNEXPECTED_ERROR);
      const r = this.$i18n;
      delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, r.__disposer && (r.__disposer(), delete r.__disposer, delete r.__extender), n.__deleteInstance(s), delete this.$i18n
    }
  }
}

function wi(e, t) {
  e.locale = t.locale || e.locale, e.fallbackLocale = t.fallbackLocale || e.fallbackLocale, e.missing = t.missing || e.missing, e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn, e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn, e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages, e.postTranslation = t.postTranslation || e.postTranslation, e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage, e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml, e.sync = t.sync || e.sync, e.__composer[po](t.pluralizationRules || e.pluralizationRules);
  const n = Ir(e.locale, {messages: t.messages, __i18n: t.__i18n});
  return Object.keys(n).forEach(s => e.mergeLocaleMessage(s, n[s])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach(s => e.mergeDateTimeFormat(s, t.datetimeFormats[s])), t.numberFormats && Object.keys(t.numberFormats).forEach(s => e.mergeNumberFormat(s, t.numberFormats[s])), e
}

const Cr = {
  tag: {type: [String, Object]},
  locale: {type: String},
  scope: {
    type: String,
    validator: e => e === "parent" || e === "global",
    default: "parent"
  },
  i18n: {type: Object}
};

function xf({slots: e}, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((s, r) => [...s, ...r.type === Re ? r.children : [r]], []) : t.reduce((n, s) => {
    const r = e[s];
    return r && (n[s] = r()), n
  }, ne())
}

function bo() {
  return Re
}

const Cf = $e({
  name: "i18n-t",
  props: ge({
    keypath: {type: String, required: !0},
    plural: {type: [Number, String], validator: e => me(e) || !isNaN(e)}
  }, Cr),
  setup(e, t) {
    const {slots: n, attrs: s} = t,
      r = e.i18n || bs({useScope: e.scope, __useComponent: !0});
    return () => {
      const i = Object.keys(n).filter(_ => _[0] !== "_"), l = ne();
      e.locale && (l.locale = e.locale), e.plural !== void 0 && (l.plural = U(e.plural) ? +e.plural : e.plural);
      const o = xf(t, i), a = r[Xs](e.keypath, o, l), f = ge(ne(), s),
        m = U(e.tag) || q(e.tag) ? e.tag : bo();
      return Kl(m, f, a)
    }
  }
}), Fi = Cf;

function Nf(e) {
  return ue(e) && !U(e[0])
}

function yo(e, t, n, s) {
  const {slots: r, attrs: i} = t;
  return () => {
    const l = {part: !0};
    let o = ne();
    e.locale && (l.locale = e.locale), U(e.format) ? l.key = e.format : q(e.format) && (U(e.format.key) && (l.key = e.format.key), o = Object.keys(e.format).reduce((T, x) => n.includes(x) ? ge(ne(), T, {[x]: e.format[x]}) : T, ne()));
    const a = s(e.value, l, o);
    let f = [l.key];
    ue(a) ? f = a.map((T, x) => {
      const R = r[T.type],
        w = R ? R({[T.type]: T.value, index: x, parts: a}) : [T.value];
      return Nf(w) && (w[0].key = `${T.type}-${x}`), w
    }) : U(a) && (f = [a]);
    const m = ge(ne(), i), _ = U(e.tag) || q(e.tag) ? e.tag : bo();
    return Kl(_, m, f)
  }
}

const Of = $e({
  name: "i18n-n",
  props: ge({
    value: {type: Number, required: !0},
    format: {type: [String, Object]}
  }, Cr),
  setup(e, t) {
    const n = e.i18n || bs({useScope: e.scope, __useComponent: !0});
    return yo(e, t, uo, (...s) => n[qs](...s))
  }
}), Ri = Of;

function Pf(e, t) {
  const n = e;
  if (e.mode === "composition") return n.__getInstance(t) || e.global;
  {
    const s = n.__getInstance(t);
    return s != null ? s.__composer : e.global.__composer
  }
}

function Af(e) {
  const t = l => {
    const {instance: o, value: a} = l;
    if (!o || !o.$) throw ke(De.UNEXPECTED_ERROR);
    const f = Pf(e, o.$), m = Mi(a);
    return [Reflect.apply(f.t, f, [...ki(m)]), f]
  };
  return {
    created: (l, o) => {
      const [a, f] = t(o);
      rs && e.global === f && (l.__i18nWatcher = $t(f.locale, () => {
        o.instance && o.instance.$forceUpdate()
      })), l.__composer = f, l.textContent = a
    }, unmounted: l => {
      rs && l.__i18nWatcher && (l.__i18nWatcher(), l.__i18nWatcher = void 0, delete l.__i18nWatcher), l.__composer && (l.__composer = void 0, delete l.__composer)
    }, beforeUpdate: (l, {value: o}) => {
      if (l.__composer) {
        const a = l.__composer, f = Mi(o);
        l.textContent = Reflect.apply(a.t, a, [...ki(f)])
      }
    }, getSSRProps: l => {
      const [o] = t(l);
      return {textContent: o}
    }
  }
}

function Mi(e) {
  if (U(e)) return {path: e};
  if (G(e)) {
    if (!("path" in e)) throw ke(De.REQUIRED_VALUE, "path");
    return e
  } else throw ke(De.INVALID_VALUE)
}

function ki(e) {
  const {path: t, locale: n, args: s, choice: r, plural: i} = e, l = {},
    o = s || {};
  return U(n) && (l.locale = n), me(r) && (l.plural = r), me(i) && (l.plural = i), [t, o, l]
}

function Df(e, t, ...n) {
  const s = G(n[0]) ? n[0] : {};
  (J(s.globalInstall) ? s.globalInstall : !0) && ([Fi.name, "I18nT"].forEach(i => e.component(i, Fi)), [Ri.name, "I18nN"].forEach(i => e.component(i, Ri)), [Ui.name, "I18nD"].forEach(i => e.component(i, Ui))), e.directive("t", Af(t))
}

const wf = xt("global-vue-i18n");

function Ff(e = {}) {
  const t = __VUE_I18N_LEGACY_API__ && J(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__,
    n = J(e.globalInjection) ? e.globalInjection : !0,
    s = new Map, [r, i] = Rf(e, t), l = xt("");

  function o(_) {
    return s.get(_) || null
  }

  function a(_, T) {
    s.set(_, T)
  }

  function f(_) {
    s.delete(_)
  }

  const m = {
    get mode() {
      return __VUE_I18N_LEGACY_API__ && t ? "legacy" : "composition"
    }, async install(_, ...T) {
      if (_.__VUE_I18N_SYMBOL__ = l, _.provide(_.__VUE_I18N_SYMBOL__, m), G(T[0])) {
        const w = T[0];
        m.__composerExtend = w.__composerExtend, m.__vueI18nExtend = w.__vueI18nExtend
      }
      let x = null;
      !t && n && (x = jf(_, m.global)), __VUE_I18N_FULL_INSTALL__ && Df(_, m, ...T), __VUE_I18N_LEGACY_API__ && t && _.mixin(If(i, i.__composer, m));
      const R = _.unmount;
      _.unmount = () => {
        x && x(), m.dispose(), R()
      }
    }, get global() {
      return i
    }, dispose() {
      r.stop()
    }, __instances: s, __getInstance: o, __setInstance: a, __deleteInstance: f
  };
  return m
}

function bs(e = {}) {
  const t = tn();
  if (t == null) throw ke(De.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw ke(De.NOT_INSTALLED);
  const n = Mf(t), s = $f(n), r = ho(t), i = kf(e, r);
  if (i === "global") return go(s, e, r), s;
  if (i === "parent") {
    let a = Uf(n, t, e.__useComponent);
    return a == null && (a = s), a
  }
  const l = n;
  let o = l.__getInstance(t);
  if (o == null) {
    const a = ge({}, e);
    "__i18n" in r && (a.__i18n = r.__i18n), s && (a.__root = s), o = xr(a), l.__composerExtend && (o[Qs] = l.__composerExtend(o)), Hf(l, t, o), l.__setInstance(t, o)
  }
  return o
}

function Rf(e, t) {
  const n = Fo(),
    s = __VUE_I18N_LEGACY_API__ && t ? n.run(() => Zs(e)) : n.run(() => xr(e));
  if (s == null) throw ke(De.UNEXPECTED_ERROR);
  return [n, s]
}

function Mf(e) {
  const t = gn(e.isCE ? wf : e.appContext.app.__VUE_I18N_SYMBOL__);
  if (!t) throw ke(e.isCE ? De.NOT_INSTALLED_WITH_PROVIDE : De.UNEXPECTED_ERROR);
  return t
}

function kf(e, t) {
  return _s(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local"
}

function $f(e) {
  return e.mode === "composition" ? e.global : e.global.__composer
}

function Uf(e, t, n = !1) {
  let s = null;
  const r = t.root;
  let i = Wf(t, n);
  for (; i != null;) {
    const l = e;
    if (e.mode === "composition") s = l.__getInstance(i); else if (__VUE_I18N_LEGACY_API__) {
      const o = l.__getInstance(i);
      o != null && (s = o.__composer, n && s && !s[_o] && (s = null))
    }
    if (s != null || r === i) break;
    i = i.parent
  }
  return s
}

function Wf(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent
}

function Hf(e, t, n) {
  El(() => {
  }, t), _r(() => {
    const s = n;
    e.__deleteInstance(t);
    const r = s[Qs];
    r && (r(), delete s[Qs])
  }, t)
}

const Vf = ["locale", "fallbackLocale", "availableLocales"],
  $i = ["t", "rt", "d", "n", "tm", "te"];

function jf(e, t) {
  const n = Object.create(null);
  return Vf.forEach(r => {
    const i = Object.getOwnPropertyDescriptor(t, r);
    if (!i) throw ke(De.UNEXPECTED_ERROR);
    const l = Ee(i.value) ? {
      get() {
        return i.value.value
      }, set(o) {
        i.value.value = o
      }
    } : {
      get() {
        return i.get && i.get()
      }
    };
    Object.defineProperty(n, r, l)
  }), e.config.globalProperties.$i18n = n, $i.forEach(r => {
    const i = Object.getOwnPropertyDescriptor(t, r);
    if (!i || !i.value) throw ke(De.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${r}`, i)
  }), () => {
    delete e.config.globalProperties.$i18n, $i.forEach(r => {
      delete e.config.globalProperties[`$${r}`]
    })
  }
}

const Kf = $e({
  name: "i18n-d",
  props: ge({
    value: {type: [Number, Date], required: !0},
    format: {type: [String, Object]}
  }, Cr),
  setup(e, t) {
    const n = e.i18n || bs({useScope: e.scope, __useComponent: !0});
    return yo(e, t, co, (...s) => n[Js](...s))
  }
}), Ui = Kf;
Ef();
Zu(wu);
zu(Ju);
ef(so);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const e = Rt();
  e.__INTLIFY__ = !0, Fu(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
const vo = jc, Yf = ["de", "en"], Bf = () => window.i18nApp.global;
var As = null;
const Gf = Yf.reduce((e, t) => (e[t] = [t, t === "en" ? void 0 : "en", t === "de" ? void 0 : "de"].filter(n => n !== void 0), t === "en" && (e[t] = [...e[t], "en-US"]), e), {});

function Xf(e) {
  return function (...t) {
    if (t.length >= 2) {
      const n = t[1];
      if (console.log(t, typeof n), typeof n == "number" || typeof n == "string" && !isNaN(parseFloat(n)) && isFinite(n)) {
        const s = parseFloat(n), r = t[2],
          i = typeof r == "object" && r !== null && !Array.isArray(r) ? {
            ...r,
            count: s,
            n: s
          } : {count: s, n: s}, l = [t[0], i];
        return console.log(i), e.apply(this, l)
      }
    }
    return e.apply(this, t)
  }
}

function Jf(e) {
  const t = {
    fallbackLocale: Gf,
    locale: navigator?.language ?? "en",
    legacy: !1, ...e,
    messages: vo
  };
  return As = Ff(t), globalThis.i18nApp = As, As
}

function qf(e) {
  return Jf(e)
}

function Ot(e) {
  const {t, d: n, n: s, ...r} = bs({});
  return {...r, t: Xf(t), d: n, n: s}
}

const Qf = {class: "section"}, Zf = {class: "space-y-3"}, zf = {class: "card"},
  ed = {class: "space-y-2"}, td = {class: "card-content"},
  nd = {class: "text-gray-900"}, sd = {class: "card-content"},
  rd = {class: "text-gray-900"}, id = {class: "card info-box-green"},
  ld = {class: "space-y-2"}, od = {class: "card-white-border"},
  ad = {class: "text-gray-900"}, cd = {class: "card-white-border"},
  ud = {class: "text-gray-900"}, fd = {class: "card-white-border"},
  dd = {class: "text-gray-900"}, md = {class: "card-white-border"},
  pd = {class: "text-gray-900"}, _d = {class: "card info-box-purple"},
  hd = {class: "space-y-2"}, gd = {class: "card-white"},
  bd = {class: "text-gray-900 flex items-center gap-2"},
  yd = {class: "card-white"}, vd = {class: "text-gray-900"}, Ed = $e({
    __name: "FileMergingDemo", setup(e) {
      const {t, tm: n} = Ot(), s = dt(() => {
        const r = n("");
        return Object.keys(r).length
      });
      return (r, i) => (Pe(), Ae("section", Qf, [i[10] || (i[10] = Hl('<h2 class="section-title">File Merging Demo</h2><p class="text-description"> Demonstrates how the plugin merges translation keys from multiple JSON files </p><div class="info-box info-box-blue mb-4"><h3 class="info-title-blue">How it works:</h3><ul class="info-list text-xs text-blue-800"><li class="info-list-item"><span class="bullet-blue">•</span><span>Translation keys from <span class="file-path-blue">locales/en.json</span> are merged with keys from <span class="file-path-blue">components/FileMergingDemo.en.json</span></span></li><li class="info-list-item"><span class="bullet-blue">•</span><span>Component-specific files complement (not override) the main locale files</span></li><li class="info-list-item"><span class="bullet-blue">•</span><span>All keys are available with full type safety across the application</span></li></ul></div>', 3)), y("div", Zf, [y("div", zf, [i[2] || (i[2] = y("h3", {class: "subsection-title-sm"}, [It(" From "), y("span", {class: "file-path"}, "locales/en.json")], -1)), y("div", ed, [y("div", td, [i[0] || (i[0] = y("span", {class: "text-gray-500 text-xs"}, "App.fruits.label:", -1)), y("p", nd, H(B(t)("App.fruits.label", {
        amount: 5,
        fruit: "apples"
      })), 1)]), y("div", sd, [i[1] || (i[1] = y("span", {class: "text-gray-500 text-xs"}, "Greeting.message:", -1)), y("p", rd, H(B(t)("Greeting.message")), 1)])])]), y("div", id, [i[7] || (i[7] = y("h3", {class: "text-sm font-semibold text-green-900 mb-3"}, [It(" From "), y("span", {class: "file-path-green"}, "components/FileMergingDemo.en.json")], -1)), y("div", ld, [y("div", od, [i[3] || (i[3] = y("span", {class: "text-green-600 text-xs"}, "FileMergingDemo.title:", -1)), y("p", ad, H(B(t)("FileMergingDemo.title")), 1)]), y("div", cd, [i[4] || (i[4] = y("span", {class: "text-green-600 text-xs"}, "FileMergingDemo.description:", -1)), y("p", ud, H(B(t)("FileMergingDemo.description")), 1)]), y("div", fd, [i[5] || (i[5] = y("span", {class: "text-green-600 text-xs"}, "FileMergingDemo.feature.typeCheck:", -1)), y("p", dd, H(B(t)("FileMergingDemo.feature.typeCheck")), 1)]), y("div", md, [i[6] || (i[6] = y("span", {class: "text-green-600 text-xs"}, "FileMergingDemo.feature.autoMerge:", -1)), y("p", pd, H(B(t)("FileMergingDemo.feature.autoMerge")), 1)])])]), y("div", _d, [i[9] || (i[9] = y("h3", {class: "text-sm font-semibold text-purple-900 mb-3"}, " Merged Result - All keys accessible with autocomplete ", -1)), y("div", hd, [y("div", gd, [y("div", bd, [i[8] || (i[8] = y("svg", {
        class: "icon-success",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
      }, [y("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M5 13l4 4L19 7"
      })], -1)), y("span", null, H(B(t)("FileMergingDemo.merged.success", {count: s.value})), 1)])]), y("div", yd, [y("p", vd, H(B(t)("FileMergingDemo.merged.typeSafety")), 1)])])])]), i[11] || (i[11] = y("div", {class: "code mt-4"}, [y("p", {class: "text-xs text-gray-400 mb-2 font-semibold"}, "File structure:"), y("pre", {class: "text-xs text-green-400 font-mono"}, `example/src/
├── locales/
│   ├── en.json              ← Main translations
│   └── de.json              ← Main translations
└── components/
    └── FileMergingDemo.en.json  ← Component-specific (merged)
    └── FileMergingDemo.de.json  ← Component-specific (merged)`)], -1))]))
    }
  }), Td = {class: "section"}, Sd = {class: "info-box info-box-amber mb-4"},
  Ld = {class: "info-list info-text-amber"}, Id = {class: "info-list-item"},
  xd = {class: "info-list-item"}, Cd = {class: "mb-6"},
  Nd = {class: "flex flex-col gap-2"}, Od = {class: "label-bold"},
  Pd = {class: "text-blue-600"}, Ad = {class: "grid-2 mb-4"},
  Dd = {class: "card-gray"}, wd = {class: "code-label"},
  Fd = {class: "text-sm font-medium text-gray-900"}, Rd = {class: "text-hint"},
  Md = {class: "card-gray"}, kd = {class: "code-label"},
  $d = {class: "text-sm font-medium text-gray-900"}, Ud = {class: "text-hint"},
  Wd = {class: "card-gray"}, Hd = {class: "code-label"},
  Vd = {class: "text-sm font-medium text-gray-900"}, jd = {class: "text-hint"},
  Kd = {class: "card-gray"}, Yd = {class: "code-label"},
  Bd = {class: "text-sm font-medium text-gray-900"}, Gd = {class: "text-hint"},
  Xd = {class: "space-y-3"}, Jd = {class: "info-box info-box-green"},
  qd = {class: "info-text-green"}, Qd = {class: "info-box info-box-blue"},
  Zd = {class: "info-text-blue"}, zd = {class: "mt-6 divider"},
  em = {class: "grid-2-even mb-3"}, tm = {class: "form-group flex-1"},
  nm = {class: "form-group flex-1"}, sm = {class: "info-box-purple px-4 py-3"},
  rm = {class: "info-text-purple"}, im = $e({
    __name: "PluralizationDemo", setup(e) {
      const {t} = Ot(), n = kt(0), s = kt(1), r = kt("apple"),
        i = dt(() => t(`App.fruits.${r.value}`, s.value, {amount: s.value})),
        l = o => o === 0 ? "zero" : o === 1 ? "one" : "many";
      return (o, a) => (Pe(), Ae("section", Td, [a[13] || (a[13] = y("h2", {class: "section-title"}, "Pluralization Demo", -1)), a[14] || (a[14] = y("p", {class: "text-description"}, " Demonstrates how vue-i18n handles pluralization with type-safe translation keys ", -1)), y("div", Sd, [a[5] || (a[5] = y("h3", {class: "info-title-amber"}, "How Pluralization Works:", -1)), y("ul", Ld, [y("li", Id, [a[3] || (a[3] = y("span", {class: "bullet-amber"}, "•", -1)), y("span", null, H(B(t)("PluralizationDemo.explanation.format")), 1)]), y("li", xd, [a[4] || (a[4] = y("span", {class: "bullet-amber"}, "•", -1)), y("span", null, H(B(t)("PluralizationDemo.explanation.parameter")), 1)])])]), y("div", Cd, [y("label", Nd, [y("span", Od, [a[6] || (a[6] = It("Adjust Count: ", -1)), y("span", Pd, H(n.value), 1)]), qt(y("input", {
        type: "range",
        min: "0",
        max: "10",
        "onUpdate:modelValue": a[0] || (a[0] = f => n.value = f),
        class: "range"
      }, null, 512), [[ns, n.value]])])]), y("div", Ad, [y("div", Dd, [y("div", wd, "t('PluralizationDemo.items', " + H(n.value) + "'):", 1), y("div", Fd, H(B(t)("PluralizationDemo.items", n.value)), 1), y("div", Rd, " Count: " + H(n.value) + " → " + H(l(n.value)), 1)]), y("div", Md, [y("div", kd, "t('PluralizationDemo.people', " + H(n.value) + ")", 1), y("div", $d, H(B(t)("PluralizationDemo.people", n.value)), 1), y("div", Ud, " Count: " + H(n.value) + " → " + H(l(n.value)), 1)]), y("div", Wd, [y("div", Hd, "t('PluralizationDemo.messages', " + H(n.value) + ")", 1), y("div", Vd, H(B(t)("PluralizationDemo.messages", n.value)), 1), y("div", jd, " Count: " + H(n.value) + " → " + H(l(n.value)), 1)]), y("div", Kd, [y("div", Yd, "t('PluralizationDemo.files.uploaded', " + H(n.value) + ")", 1), y("div", Bd, H(B(t)("PluralizationDemo.files.uploaded", n.value)), 1), y("div", Gd, " Count: " + H(n.value) + " → " + H(l(n.value)), 1)])]), y("div", Xd, [y("div", Jd, [a[7] || (a[7] = y("div", {class: "icon-box"}, [y("svg", {
        class: "icon-green",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
      }, [y("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"
      })]), y("span", {class: "text-sm font-semibold text-green-900"}, "Shopping Cart")], -1)), y("p", qd, H(B(t)("PluralizationDemo.cart.status", n.value)), 1)]), y("div", Qd, [a[8] || (a[8] = y("div", {class: "icon-box"}, [y("svg", {
        class: "icon-blue",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
      }, [y("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
      })]), y("span", {class: "text-sm font-semibold text-blue-900"}, "Notifications")], -1)), y("p", Zd, H(B(t)("PluralizationDemo.notifications.unread", n.value)), 1)])]), y("div", zd, [a[12] || (a[12] = y("h3", {class: "subsection-title"}, "Combined Pluralization + Interpolation", -1)), y("div", em, [y("label", tm, [a[9] || (a[9] = y("span", {class: "label-bold"}, "Fruit Count:", -1)), qt(y("input", {
        type: "number",
        min: "0",
        step: "1",
        "onUpdate:modelValue": a[1] || (a[1] = f => s.value = f),
        class: "input"
      }, null, 512), [[ns, s.value]])]), y("label", nm, [a[11] || (a[11] = y("span", {class: "label-bold"}, "Fruit Type:", -1)), qt(y("select", {
        "onUpdate:modelValue": a[2] || (a[2] = f => r.value = f),
        class: "select"
      }, [...a[10] || (a[10] = [y("option", {value: "apple"}, "apple", -1), y("option", {value: "banana"}, "banana", -1)])], 512), [[Bl, r.value]])])]), y("div", sm, [y("p", rm, H(B(t)("App.fruits.label", s.value, {fruit: i.value})), 1)])])]))
    }
  }), lm = {class: "section"}, om = {class: "grid-2-even mb-4"},
  am = {class: "form-group"}, cm = {class: "form-group"},
  um = {class: "space-y-3"}, fm = {class: "info-box-purple px-4 py-3"},
  dm = {class: "info-text-purple"}, mm = {class: "info-box-indigo px-4 py-3"},
  pm = {class: "info-text-indigo"}, _m = {class: "info-box-pink px-4 py-3"},
  hm = {class: "info-text-pink"}, gm = {class: "mt-4 p-3 info-box-gray"},
  bm = {class: "space-y-1 text-xs text-gray-700"}, ym = {class: "code-example"},
  vm = {class: "code-example"}, Em = {class: "code-example"}, Tm = $e({
    __name: "InterpolationDemo", setup(e) {
      const {t} = Ot(), n = kt("John"), s = kt(25);
      return (r, i) => (Pe(), Ae("section", lm, [i[5] || (i[5] = y("h2", {class: "section-title"}, "Interpolation Demo", -1)), i[6] || (i[6] = y("p", {class: "text-description"}, " Demonstrates parameter interpolation with type-safe translation keys ", -1)), y("div", om, [y("label", am, [i[2] || (i[2] = y("span", {class: "label-bold"}, "Name:", -1)), qt(y("input", {
        type: "text",
        "onUpdate:modelValue": i[0] || (i[0] = l => n.value = l),
        class: "input"
      }, null, 512), [[ns, n.value]])]), y("label", cm, [i[3] || (i[3] = y("span", {class: "label-bold"}, "Age:", -1)), qt(y("input", {
        type: "number",
        min: "0",
        "onUpdate:modelValue": i[1] || (i[1] = l => s.value = l),
        class: "input"
      }, null, 512), [[ns, s.value]])])]), y("div", um, [y("div", fm, [y("p", dm, H(B(t)("InterpolationDemo.welcome", {name: n.value})), 1)]), y("div", mm, [y("p", pm, H(B(t)("InterpolationDemo.profile", {
        name: n.value,
        age: s.value
      })), 1)]), y("div", _m, [y("p", hm, H(B(t)("InterpolationDemo.birthday", {age: s.value + 1})), 1)])]), y("div", gm, [i[4] || (i[4] = y("p", {class: "text-xs text-gray-600 mb-2 font-semibold"}, "Code examples:", -1)), y("ul", bm, [y("li", ym, " t('InterpolationDemo.welcome', {name: " + H(n.value) + ") ", 1), y("li", vm, " t('InterpolationDemo.welcome', {name: " + H(n.value) + ", age: " + H(s.value) + " }) ", 1), y("li", Em, " t('InterpolationDemo.profile', {age: " + H(s.value) + " + 1}) ", 1)])])]))
    }
  }), Sm = {class: "section"}, Lm = {class: "space-y-3"}, Im = {class: "card"},
  xm = {class: "space-y-2"}, Cm = {class: "setting-item"},
  Nm = {class: "text-sm"}, Om = {class: "text-xs text-gray-500"},
  Pm = {class: "setting-item"}, Am = {class: "text-sm"},
  Dm = {class: "text-xs text-gray-500"}, wm = {class: "setting-item"},
  Fm = {class: "text-sm"}, Rm = {class: "text-xs text-gray-500"},
  Mm = {class: "card"}, km = {class: "space-y-2"},
  $m = {class: "status-success"}, Um = {class: "status-warning"},
  Wm = {class: "status-error"}, Hm = $e({
    __name: "NestedKeysDemo", setup(e) {
      const {t} = Ot();
      return (n, s) => (Pe(), Ae("section", Sm, [s[2] || (s[2] = y("h2", {class: "section-title"}, "Nested Keys Demo", -1)), s[3] || (s[3] = y("p", {class: "text-description"}, " Demonstrates accessing deeply nested translation keys with type safety ", -1)), y("div", Lm, [y("div", Im, [s[0] || (s[0] = y("h3", {class: "subsection-title"}, "User Settings", -1)), y("div", xm, [y("div", Cm, [y("span", Nm, H(B(t)("NestedKeysDemo.settings.theme.label")), 1), y("span", Om, H(B(t)("NestedKeysDemo.settings.theme.description")), 1)]), y("div", Pm, [y("span", Am, H(B(t)("NestedKeysDemo.settings.notifications.label")), 1), y("span", Dm, H(B(t)("NestedKeysDemo.settings.notifications.description")), 1)]), y("div", wm, [y("span", Fm, H(B(t)("NestedKeysDemo.settings.privacy.label")), 1), y("span", Rm, H(B(t)("NestedKeysDemo.settings.privacy.description")), 1)])])]), y("div", Mm, [s[1] || (s[1] = y("h3", {class: "subsection-title"}, "Status Messages", -1)), y("div", km, [y("div", $m, H(B(t)("NestedKeysDemo.status.success")), 1), y("div", Um, H(B(t)("NestedKeysDemo.status.warning")), 1), y("div", Wm, H(B(t)("NestedKeysDemo.status.error")), 1)])])]), s[4] || (s[4] = Hl('<div class="mt-4 p-3 info-box-gray"><p class="text-xs text-gray-600 mb-2 font-semibold">Accessing nested keys:</p><ul class="space-y-1 text-xs text-gray-700"><li class="code-example">t(&#39;NestedKeysDemo.settings.theme.label&#39;)</li><li class="code-example">t(&#39;NestedKeysDemo.status.success&#39;)</li></ul></div>', 1))]))
    }
  }), Vm = {class: "section"}, jm = {class: "space-y-2"},
  Km = {class: "badge-blue"}, Ym = $e({
    __name: "MenuDemo", setup(e) {
      const {tm: t, rt: n} = Ot();
      return (s, r) => (Pe(), Ae("section", Vm, [r[0] || (r[0] = y("h2", {class: "section-title"}, "Menu Demo (Array via tm)", -1)), r[1] || (r[1] = y("p", {class: "text-description"}, [It(" Demonstrates using "), y("span", {class: "code-inline"}, "tm()"), It(" to access translation messages as arrays ")], -1)), y("ul", jm, [(Pe(!0), Ae(Re, null, Tl(B(t)("App.menu"), (i, l) => (Pe(), Ae("li", {
        key: l,
        class: "menu-item"
      }, [y("span", Km, H(l + 1), 1), y("span", null, H(B(n)(i)), 1)]))), 128))])]))
    }
  }), Bm = {class: "section"}, Gm = {class: "section-title"},
  Xm = {class: "sub-section"}, Jm = {class: "code"},
  qm = {class: "sub-section"}, Qm = ["innerHTML"], Zm = $e({
    __name: "MessagesViewer", setup(e) {
      const {tm: t, locale: n} = Ot(), s = dt(() => t("App"));
      return (r, i) => (Pe(), Ae("section", Bm, [y("h2", Gm, "Translation Messages (" + H(B(n)) + ")", 1), y("div", Xm, [i[0] || (i[0] = y("p", {class: "label"}, [It(" Shows all translation messages using "), y("b", null, "tm('App')")], -1)), y("pre", Jm, H(JSON.stringify(JSON.parse(JSON.stringify(s.value)), null, 4)), 1)]), y("div", qm, [i[1] || (i[1] = y("p", {class: "label"}, [It(" Shows all translation messages using "), y("b", null, 'import {useI18nTypeSafe,messages} from "virtual:unplug-i18n-dts-generation";')], -1)), y("pre", {
        class: "code",
        innerHTML: JSON.stringify(JSON.parse(JSON.stringify(B(vo))), null, 4)
      }, null, 8, Qm)])]))
    }
  }), zm = {class: "space-y-6"}, ep = $e({
    __name: "Demo", setup(e) {
      return (t, n) => (Pe(), Ae("div", zm, [ce(Ed), ce(im), ce(Tm), ce(Hm), ce(Ym), ce(Zm)]))
    }
  }), tp = {class: ""}, np = $e({
    __name: "Greeting", setup(e) {
      const {t} = Ot();
      return (n, s) => (Pe(), Ae("h1", tp, H(B(t)("Greeting.message", "not found")), 1))
    }
  }), sp = {class: "flex items-center gap-3"},
  rp = {for: "language-select", class: "label"}, ip = ["value"], lp = $e({
    __name: "LanguageDropdown", setup(e) {
      const t = Bf(), {t: n} = Ot(), s = kt("en");
      return $t(s, r => {
        r && (t.locale.value = r)
      }, {immediate: !0}), (r, i) => (Pe(), Ae("div", sp, [y("label", rp, H(B(n)("LanguageDropdown.label")), 1), qt(y("select", {
        id: "language-select",
        "onUpdate:modelValue": i[0] || (i[0] = l => s.value = l),
        class: "select"
      }, [(Pe(!0), Ae(Re, null, Tl(B(t).availableLocales, l => (Pe(), Ae("option", {
        key: l,
        value: l
      }, H(l), 9, ip))), 128))], 512), [[Bl, s.value]])]))
    }
  }), op = {class: "min-h-screen bg-gray-50"},
  ap = {class: "max-w-4xl mx-auto px-4 py-8 space-y-8"},
  cp = {class: "flex justify-between items-center"}, up = $e({
    __name: "App", setup(e) {
      return document.title = "i18n Type Safe Demo", (t, n) => (Pe(), Ae("div", op, [y("div", ap, [y("header", cp, [n[0] || (n[0] = y("div", null, [y("h1", {class: "text-2xl font-semibold text-gray-900"}, "i18n Type Safe Demo"), y("p", {class: "text-sm text-gray-600 mt-1"}, "Vue I18n with TypeScript type safety")], -1)), ce(lp)]), ce(np), ce(ep)])]))
    }
  }), Eo = Wc(up);
Eo.use(qf());
Eo.mount("#app");</script >

<body >
<div id="app" class="" ></div >
</body >
</html >
