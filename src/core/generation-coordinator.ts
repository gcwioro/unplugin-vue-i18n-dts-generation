import path from "node:path";
import {promises as fs} from "node:fs";
import type {Logger} from "vite";
import {detectKeyConflicts, ensureDir, writeFileAtomic} from "../utils";
import {
  createAutogeneratedBanner,
  renderMessagesModule,
  renderRuntimeModuleTs,
} from "../generator";
import type {JSONObject, JSONValue} from "../types";
import {CombinedMessages} from "./combined-messages";
import {compileGeneratedProgram} from "./compile-generated-program";

export interface GenerationOptions {
  typesPath: string;
  virtualFilePath?: string;
  baseLocale: string;
  banner?: string;
  sourceId: string;
  logger?: Logger;
}

interface GenerationResult {
  filesWritten: number;
  totalFiles: number;
  durations: {
    content: number;
    write: number;
    total: number;
  };
  filesList: string[];
}

/**
 * Coordinates the generation of TypeScript definition files
 */
export class GenerationCoordinator {
  constructor(private options: GenerationOptions) {
  }

  /**
   * Generate type definition and virtual module files
   */
  async generateFiles(
    messages: Record<string, JSONValue>,
    rootDir: string
  ): Promise<GenerationResult> {
    const start = performance.now();

    const combinedMessages = new CombinedMessages(
      messages as Record<string, JSONObject>,
      this.options.baseLocale
    );

    const typesOutPath = path.isAbsolute(this.options.typesPath)
      ? this.options.typesPath
      : path.join(rootDir, this.options.typesPath);

    const virtualOutPath = this.options.virtualFilePath
      ? path.isAbsolute(this.options.virtualFilePath)
        ? this.options.virtualFilePath
        : path.join(rootDir, this.options.virtualFilePath)
      : undefined;

    const startContentGen = performance.now();
    this.validateMessages(messages);
    const {runtimeJs, runtimeDts, messagesTs} = await this.generateContent(combinedMessages);
    const contentGenDuration = Math.round(performance.now() - startContentGen);

    const startWrite = performance.now();
    const messagesOutPath = this.resolveMessagesOutPath(typesOutPath, virtualOutPath);
    const filesWritten = await this.writeFiles(
      {
        typesPath: typesOutPath,
        runtimePath: virtualOutPath,
        messagesPath: messagesOutPath,
      },
      {
        runtimeDts,
        runtimeJs: virtualOutPath ? runtimeJs : undefined,
        messagesTs,
      },
    );
    const writeDuration = Math.round(performance.now() - startWrite);

    const totalDuration = Math.round(performance.now() - start);

    const filesList = [
      path.relative(rootDir, typesOutPath),
      path.relative(rootDir, messagesOutPath),
    ];
    if (virtualOutPath) {
      filesList.push(path.relative(rootDir, virtualOutPath));
    }

    return {
      filesWritten,
      totalFiles: virtualOutPath ? 3 : 2,
      durations: {
        content: contentGenDuration,
        write: writeDuration,
        total: totalDuration,
      },
      filesList,
    };
  }

  private validateMessages(messages: Record<string, JSONValue>): void {
    const conflicts = detectKeyConflicts(messages);
    if (conflicts.length > 0) {
      this.options.logger?.warn('⚠️  Conflicting translation keys detected:', {
        timestamp: true,
      });
      for (const conflict of conflicts) {
        this.options.logger?.warn(`   ${conflict}`, {timestamp: true});
      }
    }
  }

  private async generateContent(combinedMessages: CombinedMessages<string, JSONObject>): Promise<{
    runtimeJs: string;
    runtimeDts: string;
    messagesTs: string;
  }> {
    const messagesTs = renderMessagesModule({
      combinedMessages,
      banner: this.options.banner,
    });

    const runtimeTs = renderRuntimeModuleTs({
      combinedMessages,
      banner: this.options.banner,
      sourceId: this.options.sourceId,
    });

    const {runtimeJs, runtimeDts} = compileGeneratedProgram({
      runtimeSource: runtimeTs,
      messagesSource: messagesTs,
    });

    const declarations = this.buildDeclarations(runtimeDts, combinedMessages.contentId);

    return {runtimeJs, runtimeDts: declarations, messagesTs};
  }

  private async writeFiles(
    paths: {typesPath: string; runtimePath?: string; messagesPath: string},
    contents: {runtimeDts: string; runtimeJs?: string; messagesTs: string}
  ): Promise<number> {
    let filesWritten = 0;

    await ensureDir(paths.typesPath);
    if (await this.shouldWriteFile(paths.typesPath, contents.runtimeDts)) {
      await writeFileAtomic(paths.typesPath, contents.runtimeDts);
      filesWritten++;
    }

    if (paths.runtimePath && contents.runtimeJs !== undefined) {
      await ensureDir(paths.runtimePath);
      if (await this.shouldWriteFile(paths.runtimePath, contents.runtimeJs)) {
        await writeFileAtomic(paths.runtimePath, contents.runtimeJs);
        filesWritten++;
      }
    }

    await ensureDir(paths.messagesPath);
    if (await this.shouldWriteFile(paths.messagesPath, contents.messagesTs)) {
      await writeFileAtomic(paths.messagesPath, contents.messagesTs);
      filesWritten++;
    }

    return filesWritten;
  }

  private resolveMessagesOutPath(typesPath: string, runtimePath?: string): string {
    if (runtimePath) {
      return path.join(path.dirname(runtimePath), 'messages.ts');
    }
    return path.join(path.dirname(typesPath), 'messages.ts');
  }

  private buildDeclarations(runtimeDts: string, contentId: string): string {
    const banner = createAutogeneratedBanner(this.options.banner, contentId);
    const moduleId = this.options.sourceId;

    const indent = (text: string): string =>
      text
        .split('\n')
        .map((line) => (line.length === 0 ? '' : `  ${line}`))
        .join('\n');

    const runtimeBlock = `declare module '${moduleId}' {\n${indent(runtimeDts.trim())}\n}\n`;

    const messagesBlock = `declare module '${moduleId}/messages' {\n  export {messages as default, messages, supportedLanguages, baseLocale} from '${moduleId}';\n  export type {MessageSchemaGen, MessagesType, AllTranslations, AllSupportedLanguages, AllTranslationKeys, SupportedLanguage} from '${moduleId}';\n}\n`;

    const combined = `${banner}${runtimeBlock}\n${messagesBlock}`;
    return combined.replace(/\n*$/, '\n');
  }

  private async shouldWriteFile(filePath: string, newContent: string): Promise<boolean> {
    try {
      const existing = await fs.readFile(filePath, 'utf8');
      return existing !== newContent;
    } catch {
      return true;
    }
  }
}
